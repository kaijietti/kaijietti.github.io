<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><meta name="referrer" content="no-referrer"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"kaijietti.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!1,sidebar:!1,scrollpercent:!0},bookmark:{enable:!0,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!0,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!0,nav:{disqus:{text:"Load Disqus",order:-1}},activeClass:"valine"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="《操作系统精髓与设计原理》的读书摘录：进程的描述与控制"><meta property="og:type" content="article"><meta property="og:title" content="操作系统精髓与设计原理：进程的描述与控制"><meta property="og:url" content="https://kaijietti.github.io/2021/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/index.html"><meta property="og:site_name" content="GopherKai"><meta property="og:description" content="《操作系统精髓与设计原理》的读书摘录：进程的描述与控制"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B1.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B5.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B3.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B4.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B6.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B7.png"><meta property="article:published_time" content="2021-03-08T02:45:56.000Z"><meta property="article:modified_time" content="2021-04-11T13:39:28.385Z"><meta property="article:author" content="kaijietti"><meta property="article:tag" content="操作系统"><meta property="article:tag" content="读书笔记"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/kaijietti/image-host/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B1.png"><link rel="canonical" href="https://kaijietti.github.io/2021/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>操作系统精髓与设计原理：进程的描述与控制 | GopherKai</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">GopherKai</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">go-hell</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签<span class="badge">5</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类<span class="badge">4</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档<span class="badge">4</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/kaijietti/kaijietti.github.io" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener external nofollow noreferrer" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kaijietti.github.io/2021/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="kaijietti"><meta itemprop="description" content="专注技术分享"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="GopherKai"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 操作系统精髓与设计原理：进程的描述与控制</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-03-08 10:45:56" itemprop="dateCreated datePublished" datetime="2021-03-08T10:45:56+08:00">2021-03-08</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-04-11 21:39:28" itemprop="dateModified" datetime="2021-04-11T21:39:28+08:00">2021-04-11</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/2021/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2021/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>12k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>11 分钟</span></span><div class="post-description">《操作系统精髓与设计原理》的读书摘录：进程的描述与控制</div></div></header><div class="post-body" itemprop="articleBody"><h1 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h1><blockquote><p>《操作系统精髓与设计原理》读书笔记</p></blockquote><h2 id="1-什么是进程"><a href="#1-什么是进程" class="headerlink" title="1 什么是进程"></a>1 什么是进程</h2><h3 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a>1.1 背景</h3><p>当前所有的多任务操作系统，都建立在进程这一概念之上。它是操作系统提供的一个非常重要的<strong>抽象</strong>。它的由来与应用程序脱不开关系。</p><p>现代操作系统的设计，应能满足系统中多个应用程序执行的需要，达到以下设计目标：</p><ul><li>资源能够被多个应用程序使用；</li><li>处理器需要在多个应用程序的执行过程中进行切换，造成应用程序同时进行的假象。</li><li>尽可能地提高处理器和 I/O 设备的利用率。</li></ul><p>为了达到这些设计目标，现代操作系统都将应用程序的执行过程抽象为一个或多个进程。进而，一个成熟的操作系统所需要满足的所有设计目标都可以表达为进程的具体需求：</p><ul><li>操作系统必具有调度多个进程并发执行的能力，从而在最大化处理器利用率的同时，为用户提供合理的响应时间；</li><li>操作系统为进程分配计算机系统的资源时，必须符合某既定的策略，同时避免死锁的发生；</li><li>操作系统应尽可能地提供进程间通信和让用户创建进程的接口，从而帮助用户设计其应用；</li></ul><h3 id="1-2-进程和进程控制块"><a href="#1-2-进程和进程控制块" class="headerlink" title="1.2 进程和进程控制块"></a>1.2 进程和进程控制块</h3><p>进程有几个定义，包括：</p><ul><li>一个正在执行的程序；</li><li>一个执行在计算机上的应用程序实例；</li><li>一个能够被调度到处理器上执行的实体；</li><li>一个活动单元，包括一串指令的执行、当前状态，以及一组正在使用的资源。</li></ul><blockquote><p>上述定义可能由于历史原因或系统原因而不适用，比如往后支持的多线程调度等。</p></blockquote><p>可以把进程认为是一个包含多个元素的独立个体，其中有两个基本元素：</p><ul><li>程序代码（可在同一应用创建的多个进程中共享）；</li><li>程序代码相关的一组数据；</li></ul><p>在进程执行过程的任意时间点上，所对应的进程拥有唯一表示其存在的元素，包括：</p><ul><li><strong>标识符</strong></li><li><strong>进程状态</strong></li><li><strong>优先级</strong>：相对于其他进程的优先级，用来确定进程被调度到处理器上执行的先后次序；</li><li><strong>程序计数器</strong></li><li><strong>内存指针</strong>：通过这些指针，，能找到该进程的代码、数据，以及和其他进程共享的内存部分；</li><li><strong>上下文</strong>：即进程执行到该时间点时处理器中寄存器的值；</li><li><strong>I/O 状态</strong>：包括 I/O 请求】被分配到该进程的 I/O 设备（如硬盘）、正在使用的文件等；</li><li><strong>记账信息</strong>：包括该进程累计占用了多少处理器时间，它的使用时间限制等。</li></ul><p>这些信息一般会存放在一个被称为<strong>进程控制块</strong>的数据结构中，往往由操作系统创建。它的重要特点之一在于，包含了足够的信息从而能够在操作系统产生中断时，打断它的执行过程，并在中断处理完成后通过进程控制块的信息恢复该进程的执行。</p><blockquote><p>后面会对上述的进程信息进行进一步的分类，专门讲进程控制块。</p></blockquote><p>可以认为进程由程序代码、程序代码相关的数据，以及其对应的进程控制块共同组成。</p><h2 id="2-进程状态"><a href="#2-进程状态" class="headerlink" title="2 进程状态"></a>2 进程状态</h2><p>操作系统的首要任务是控制进程的执行过程，这意味着它必须确定多个进程如何交替执行，以及如何为进程分配资源。为了达到这一目标，必须对进程的行为加以描述。</p><blockquote><p>本节中，行为实际上指的是状态。</p></blockquote><h3 id="2-1-双状态模型"><a href="#2-1-双状态模型" class="headerlink" title="2.1 双状态模型"></a>2.1 双状态模型</h3><p>双状态模型可以简化我们对操作系统的调度任务的观察，即帮助我们得出某种设计经验。</p><p>在双状态模型中，任意时刻，进程只可能处于两种状态，执行态或不执行态。当操作系统创建一个新的进程时，创建该进程对应的进程控制块，并将该进程投入不执行态。之后，如果当前正在运行的进程用完了分配给它的时间片，它将被中断并进入不执行态，而调度程序将调入一个处于不执行态的程序投入运行，此过程不断重复，直到所有系统中的进程执行结束。</p><center><img src="https://gitee.com/kaijietti/image-host/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B1.png" width="80%/"></center><p>双状态模型启发的经验有：</p><ul><li>每个进程必须能够被操作系统跟踪，也就是说，一个进程必须包含有一些必要的信息（如其状态信息、进程控制块等）以使得操作系统能够感知它的存在，并控制它的执行。</li><li>系统必须设计某种队列结构，来存放被暂停执行或暂时无法执行的进程的信息。</li></ul><blockquote><p>另外，实际上进程状态与系统中用于存放它们的队列存在一定关系，它们的状态以及处在某个队列都是紧密联系的，所以设计状态模型的本质上也是在设计最基本的队列结构模型，而后才有调度策略。</p></blockquote><h3 id="2-2-五状态模型"><a href="#2-2-五状态模型" class="headerlink" title="2.2 五状态模型"></a>2.2 五状态模型</h3><p>双状态模型很简单，在实际上并不适用，因为系统中<strong>并不是所有的进程都可以随时被调度执行</strong>。</p><blockquote><p>如果有某一进程由于等待 I/O 而阻塞，那么哪怕它被调度也无法执行。如果采用单一队列，调度器不能直接将最早进入队列的进程调度到处理器上并开始它的执行，而是应该确定该进程没有处于阻塞状态，且在队列中等待的时间最久。</p></blockquote><p>对此，将<strong>不执行态</strong>进一步区分为两种状态：<strong>就绪态</strong>和<strong>阻塞态</strong>。加上<strong>新创建态</strong>和<strong>结束态</strong>就构成了五状态模型。</p><p><strong>新创建态和结束态在进程管理的作用</strong>：</p><ul><li>新创建状态对应了进程刚刚被创建的状态。操作系统为其做了一些必要的工作，并为该进程分配一个标识符，创建所有与该进程相关的数据表（例如，进程控制块）。这意味着操作系统已经为该进程的执行做好了准备工作，但并未决定立即运行该进程（比如，可能因为进程数或内存容量的限制），所以需要等待操作系统接收（<code>Admit</code>）。<strong>在这种情况下，该进程运行所需要的全部管理机构都已具备，然而进程的代码尚未被载入内存</strong>。</li><li>当进程执行到结束点，或因为出现错误而被操作系统或其他进程强制撤销，系统将该进程置为结束态。此时，该进程已经无法被再次投入运行，但<strong>用于控制该进程执行相关的数据结构仍然被操作系统暂时保留，以便在其后被其他进程访问</strong>。比如，操作系统的记账模块利用操作系统保留的信息计算该进程的总运行时间，以及在运行过程中对系统资源的使用情况，从而生成最终的账单。操作系统的工具模块利用这些信息来对系统的资源利用率进行统计，或对系统的性能进行计算。当进程的这些信息不再具有利用价值时，操作系统最终撤销之前保留的控制进程的数据结构。</li></ul><p>五状态模型示意图如下：</p><center><img src="https://gitee.com/kaijietti/image-host/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B5.png" width="80%/"></center><ul><li>运行态：进程正在运行。</li><li>就绪态：进程已准备好执行，如果给它处理器，它就可以立即投入运行。</li><li>阻塞态/等待态：进程在等待某事件的发生，如 I/O 的完成。</li><li>新创建态：进程刚刚被创建，但还未被操作系统加入可执行队列。例如，一个进程刚被操作系统创建，它的进程控制块已经建立，但它的可执行代码还未载入内存。</li><li>结束态：进程结束（可能是自愿结束，也可能是发生某种错误被系统强制撤销），它所占用的系统资源被释放，但操作系统仍保留其控制结构（如进程控制块）。</li></ul><p>状态间可能存在的转换如下：</p><ul><li><strong>新创建态 -&gt; 就绪态</strong>：当操作系统准备好接收一个新进程的执行时，它将挑选一个新创建态进程，并将该进程的状态从新创建态切换到就绪态。因为性能或内存的限制，许多系统为系统中同时存在的进程设置了上限，以保证系统中不会有过多的进程而导致系统性能的下降。</li><li><strong>就绪态 -&gt; 运行态</strong>：当处理器空闲时，操作系统从处于就绪态的进程中挑选一个进程，并将其投入运行，该进程的状态也相应地从就绪态变为运行态。选择进程的动作由调度器完成。</li><li><strong>运行态 -&gt; 结束态</strong>：进程结束，或被操作系统撤销，该进程的状态也相应地从运行态转到结束态。</li><li><strong>运行态 -&gt; 就绪态</strong>：存在多种原因导致这一变化，如时间片耗尽、抢占式调度、自愿放弃处理器等。具体来说：<ul><li>多任务操作系统对进程的运行时间加上了某种限制，当某进程在执行过程中用完了分配给它的时间片时，其将会被重新切换为就绪态，从而适应多任务的执行需求；</li><li>操作系统引进进程优先级的概念。例如，某操作系统有进程 A 和 进程 B，其中进程 B 的优先级高于进程 A 的优先级。在某时刻，进程 A 处于运行态，进程 B 因等待某事件的发生而处于阻塞态。其后，进程 B 等待的时间到达，导致进程 B 被唤醒并转移到就绪态。这时，由于进程 B 的优先级高于进程 A，调度器将中断进程 A 的执行，而立即调度进程 B 到处理器上执行。</li><li>一个进程可能在运行过程中自愿放弃了自己的执行权。例如，系统的记账进程，作为背景进程，只是周期性地被调度执行，每次被调度后，这个记账进程都在完成自己的规定动作后，自愿放弃执行权。</li></ul></li><li><strong>运行态 -&gt; 阻塞态</strong>：进程在执行过程中，因为请求一些暂时得不到而必须等待的服务时，从运行态转移到阻塞态。具体来说有：<ul><li>进程调用一个操作系统的服务（如读写文件、访问共享内存等），而这些服务操作系统可能无法立即提供；</li><li>进程在执行过程中发出了 I/O 请求，从而必须等待该 I/O 请求的完成才能继续执行；</li><li>因为进程间通信的原因，一个进程在执行过程中等待另一个进程的消息才能继续往下执行。</li></ul></li><li><strong>阻塞态 -&gt; 就绪态</strong>：当进程所等待的事件到达后，它的状态从阻塞态转移到就绪态。<blockquote><p>在图中没有标出的转换如<strong>就绪态/阻塞态 -&gt; 结束态</strong>也是可能存在的：有些系统在父进程结束后，强制结束它所有子进程。这时就会导致子进程直接从就绪态或阻塞态转移到结束态。</p></blockquote></li></ul><p>对于<strong>阻塞态 -&gt; 就绪态</strong>，意味着当某事件到达时，操作系统必须遍历阻塞（等待）队列，准确地找到等待该事件到达的进程，可想而知，当有成千上万个进程处于阻塞态时，此法效率很低。</p><center><img src="https://gitee.com/kaijietti/image-host/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B3.png" width="80%/"></center><p>所以，为每一种可能到达的事件建立一个阻塞（等待）队列，将提高操作系统查找进程的速度。当某事件到达后，该事件对应的阻塞（等待）队列中所有的进程都将被转移到就绪态。</p><center><img src="https://gitee.com/kaijietti/image-host/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B4.png" width="80%/"></center><p>对于<strong>就绪态 -&gt; 运行态</strong>，如果操作系统采用了优先级调度策略，可以为每一个优先级组织一个就绪队列，这样操作系统能够较快速地找到高优先级的进程或等待时间最长的进程。</p><h3 id="2-3-进程挂起"><a href="#2-3-进程挂起" class="headerlink" title="2.3 进程挂起"></a>2.3 进程挂起</h3><blockquote><p>下面的内容需要关于虚拟存储方面的知识，并主要围绕<strong>进程挂起</strong>。</p></blockquote><p>考虑一个没有虚拟存储支持的系统，在该系统中，所有进程都必须被完全装入内存（即便是处于阻塞队列）。然而，在计算机系统中，I/O 操作往往比计算要慢得多，所以在一个单处理器系统中，处理器绝大多数时间都是闲置的。为了提高处理器的利用率，操作系统在内存中存放多个进程，如果一个进程在执行过程中发生阻塞，则立即调度另一个进程到处理器上执行。但是，因为处理器比 I/O 快太多，以至于可能所有被载入内存的进程都进入了阻塞态，而处理器仍然无事可做。</p><p>解决方案之一是增加内存的容量，并放入更多的进程。但内存的价格昂贵，且程序对内存需求的增长，往往超过内存价格随着时间下降的速度，所以<strong>更大的内存往往导致更大的进程，而不是更多的进程</strong>。</p><p>另一个解决方案就是<strong>虚拟存储技术</strong>。这一技术可以将进程的一部分或整个进程从内存交换到硬盘中。当系统中没有进程处于就绪态时，操作系统就可以用虚拟存储技术，将其中一个处于阻塞态的进程交换到硬盘，并将其状态设置为<strong>挂起状态（Suspend）</strong>，放到挂起状态对应的队列中。这样，操作系统就能腾出内存空间，从而能够调度执行另一个处于挂起状态的进程，或者另一个新创建的进程。</p><blockquote><p>交换操作仍然涉及大量的 I/O，采用这一技术可能使得系统性能更糟糕。但是，因为硬盘的 I/O 往往比计算机系统中的其他外部设备（例如，与磁带和打印机相比）快，所以采用虚拟存储技术往往会带来系统性能的提升。</p></blockquote><p>如果系统选择调度另一个之前处于挂起状态的进程，就有可能遇到该进程被载入内存后仍旧保持阻塞态，操作系统无法将其调度到处理器上执行（同时，系统花费了毫无用处的加载时间）。</p><p>解决这个问题的方法是引入新的状态。思考两个互相独立的概念：</p><ul><li>进程是否在等待某个事件（阻塞或未阻塞）</li><li>进程是否被从内存中换出（挂起或未挂起）</li></ul><p>将其进行组合出现四种状态：</p><ul><li><strong>就绪态</strong>（未阻塞，未挂起）：进程在主存中，且可被调度执行；</li><li><strong>阻塞态</strong>（阻塞，未挂起）：进程在主存中，且在等待某事件的发生；</li><li><strong>阻塞且挂起态</strong>（阻塞，挂起）：进程在辅存中，且在等待某事件的发生；</li><li><strong>就绪且挂起态</strong>（未阻塞，挂起）：进程在辅存中，且如果被调入内存，即可执行。</li></ul><p>带挂起状态的进程状态图如下所示：</p><center><img src="https://gitee.com/kaijietti/image-host/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B6.png" width="80%/"></center><p>状态之间可能存在的转换如下：</p><ul><li><strong>阻塞态 -&gt; 阻塞且挂起态</strong>：当内存空间不足时，阻塞态进程可能会被挂起。例如<ul><li>如果系统中没有就绪态进程可调度，则其中至少有一个阻塞态的进程被交换到外存中，为另一个未被阻塞的进程的执行腾出内存空间；</li><li>如果操作系统发现正在执行的进程，或即将被调入执行的进程需要更多的内存空间时，它将换出一个阻塞态的进程到外存以得到所需要的内存空间。</li></ul></li><li><strong>阻塞且挂起态 -&gt; 就绪且挂起态</strong>：当进程所等待的事件到达时，即便是在外存中，该进程切换至就绪态；</li><li><strong>就绪且挂起态 -&gt; 就绪态</strong>：当系统中无就绪态进程时，操作系统将调入一个处于就绪且挂起态的进程到内存中，并将其置为就绪态。也可能是因为处于就绪且挂起态的进程拥有比所有当前的就绪态进程更高的优先级。</li><li><strong>就绪态 -&gt; 就绪且挂起态</strong>：一般情况下，操作系统倾向于选择一个处于阻塞态的进程换出到外存中。但有时选择一个就绪态的进程换出到外存中可能是腾出大量连续内存空间的唯一办法。当然，此时操作系统会选择一个比即将进入系统的阻塞进程更低优先级的就绪态进程换出。</li><li><strong>新创建态 -&gt; 就绪且挂起态/就绪态</strong>：当一个新创建的进程进入系统（被接收）时，它要么被加入到就绪队列，要么被加入到就绪且挂起状态中。无论何种情况，操作系统都必须为该进程创建一个进程控制块，并为其预分配一个地址空间。由于可能需要处理大量新创建的进程，系统将无法保证为每个这样的进程留出足够的内存空间，以将它们完全载入内存。因此，新创建的进程被接收时放到就绪且挂起态是非常必要的，因为此时无需将它们完全载入内存。由于这种对新创建进程的用时调入机制（Just-In-Time），操作系统能够在自身非常繁忙的时候有效处理大量新创建进程的任务。</li><li><strong>阻塞且挂起态 -&gt; 阻塞态</strong>：调入内存却无法执行显得无意义，但考虑一下情形。当前执行的进程结束执行，并腾出大量的内存空间。这时，有一个在阻塞且挂起队列的进程具有比所有在就绪队列中的进程更高的优先级，且系统有理由相信该进程所等待的事件即将在不久后到达。在这一情况下，将其调入主存就显得合理了。</li><li><strong>运行态 -&gt; 就绪且挂起态</strong>：一般来说，当前处于运行态的进程在用完时间片后将进入就绪态。但如果操作系统采用了抢占式调度方案，且有一个高优先级的进程从阻塞且挂起队列中被唤醒，从而抢占了当前运行的进程的执行权。且此时因为该高优先级进程的换入导致内存空间的紧张，此时操作系统不得不中断正在运行的进程的执行，并将其换出到外存中以腾出足够的内存空间。</li></ul><p>得益于虚拟存储技术，进程可以一部分被换出到外存，而其一部分仍然在内存中。如果操作系统发现在访问某进程地址空间时，对应内容不在主存中，则该地址对应的一小段空间会被载入内存（如按需调页）。虽然，虚拟存储技术相比较（整体）交换技术看起来减少了 I/O 开销，但如果系统中存在足够多的被部分载入的进程，虚拟存储技术的使用仍然可能造成系统性能的极大降低（如发生系统颠簸，具体在页面置换讨论）。所以，即使在采用虚拟存储技术的操作系统中，（整体）交换技术的使用有时仍然是提高系统性能的有力手段。</p><p>最后总结下<strong>挂起态进程</strong>的特点：</p><ul><li>进程不能被立即调度执行；</li><li>进程可能在等待某事件的发生，但阻塞态和挂起态存在且相互独立，即使进程等待的事件到达，也无法立即将其调入执行；</li><li>进程必然是被另一个实体置为挂起态的：可能是它的父进程、操作员或操作系统；</li><li>一个处于挂起状态的进程必须等到将它挂起的实体发出明确的命令之后，才能从挂起态转换为其他状态。</li></ul><p>关于挂起，书中还有更详细的讨论（如用途和原因），此处不展开。</p><h2 id="3-进程描述符"><a href="#3-进程描述符" class="headerlink" title="3 进程描述符"></a>3 进程描述符</h2><p>前面描述了进程的状态（行为），是基于系统设计目标来设计不同状态以满足需求。为了进一步实现这些需求，就需要设计进程的数据结构（比如一些核心的字段等）。操作系统控制计算机系统中所有的事件，包括调度进程到处理器上执行、为进程分配资、响应用户请求等。<strong>可以说，操作系统是以进程为单位管理系统资源的实体</strong>。</p><center><img src="https://gitee.com/kaijietti/image-host/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B7.png" width="80%/"></center><p>那么为了控制进程和管理进程所使用的资源，操作系统需要了解哪些信息？</p><h3 id="3-1-操作系统中控制资源的结构"><a href="#3-1-操作系统中控制资源的结构" class="headerlink" title="3.1 操作系统中控制资源的结构"></a>3.1 操作系统中控制资源的结构</h3><blockquote><p>下面将简单介绍系统资源方面的信息</p></blockquote><p>假如操作系统需要管理进程和它所使用的资源，那么操作系统必须知道每个进程的当前状态。这里的状态指的是<strong>进程所拥有的资源</strong>。基本上所有操作系统都会将它所管理的信息分为以下四种类型：</p><ul><li>内存</li><li>I/O 设备</li><li>文件</li><li>进程</li></ul><p>操作系统会选择将资源使用表格进行管理，在具体的操作系统实现上这类表格的组织略有不同，其基本形式和用途如下：</p><ul><li><strong>内存表格</strong>：用于跟踪记录物理内存和二级内存（即虚拟内存）的使用状况。一部分系统内存被保留给操作系统使用，而余下的内存则在用户进程之间分配和使用（有的系统还会引入交换机制管理用户进程到硬盘的交换）。内存表格至少包含以下信息：<ul><li>物理内存的分配信息；</li><li>虚拟内存的分配信息；</li><li>每一块物理或虚拟内存的访问权限信息；</li><li>用于管理虚拟内存的信息；</li></ul></li><li><strong>I/O 设备表格</strong>：用于管理 I/O 设备和 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Channel_I/O" title="I/O 通道">I/O 通道</a>。在任意时刻，一个 I/O 设备只能分配给一个特定的进程。加入一个 I/O 操作在进行中，操作系统就需要知道其状态以及其正在使用的主存区域（如用于 DMA 交换）。</li><li>操作系统可能会维持一个<strong>文件使用表格</strong>。这些表格用于描述文件的基本信息（如在磁盘上的存储位置），它们当前的状态，以及一些其他的属性信息。在有些操作系统中，这些信息由文件系统所管理，但也存在一些操作系统本身记录和管理这些信息。</li><li><strong>进程表格</strong>：用于对系统中存在的进程进行管理。</li></ul><p>上述的表格并不是互相独立的，它们之间通过指针进行连接。内存、I/O 设备，以及文件实际上是以进程为单位进行管理，所以进程表格将通过指针与其他表格进行直接或间接地链接。</p><blockquote><p>例如，一个文件表格中记录的文件可能用指针指向它所在的 I/O 设备，同时它可能被存储在物理内存或虚拟存储中，这样文件表格要和内存表格建立联系。</p></blockquote><p>最后，这些表格都不可能凭空存在，它必须放到内存的特定区域，所以它们又都与内存管理机制相关联。其次，操作系统的初始化阶段也必须对上述的运行环境进行检测和配置（如物理内存大小、I/O 设备号等等）。</p><h3 id="3-2-进程控制块"><a href="#3-2-进程控制块" class="headerlink" title="3.2 进程控制块"></a>3.2 进程控制块</h3><blockquote><p>进程的信息，如位置、属性等</p></blockquote><p>假如操作系统需要控制和管理一个进程，那么操作系统需要知道该进程的位置以及一些基本属性。</p><p><strong>进程位置</strong></p><p>讨论进程位置前，首先需要知道<strong>进程在操作系统中是如何表达的</strong>。一般情况下，进程包含：</p><ul><li>一段或多段即将执行的程序；</li><li>与程序相关联的数据，如局部变量或全局变量，以及预先定义的常量；</li><li>程序执行时利用到的栈，用于存放该程序执行过程中调用函数时的参数；</li><li>自身状态和属性信息，便于操作系统对其进行管理和控制。</li></ul><p>通常称操作系统中用于管理和控制进程的数据结构为<strong>进程控制块（Process Control Block）</strong>，称进程所对应的程序、数据、栈以及属性信息所构成的全集为<strong>进程镜像</strong>。</p><p>进程镜像的典型构成：</p><ul><li>用户数据：用户空间的可变部分，可能包含程序数据段、用户栈空间，以及代码段中的修改部分</li><li>用户代码：可执行程序，一般是只读的</li><li>栈：进程执行过程中需要一个或多个栈，用来存储函数调用的参数以及返回地址等</li><li>进程控制块：操作系统用于控制进程所使用的数据</li></ul><p>概括地说，进程镜像包含一个进程控制块，一个用户态栈，进程的私有地址空间（代码、数据），以及进程与其他进程共享的地址空间。</p><p>可见，<strong>进程镜像就是操作系统中进程的表达</strong>。进程的位置就是进程镜像的位置，这取决于内存管理系统。</p><p>在最简单的情况下，进程镜像被连续地存放在辅存（也就是硬盘）中。当操作系统需要管理该进程时，该进程至少有一部分被加载到内存；当需要执行进程时，它的进程镜像将被完整地载入物理内存或虚拟内存中。所以，操作系统需要知道每一个进程在辅存中所存放的位置，以及它们被加载后，在主存中的存储位置。现代操作系统假设底层硬件具有页式地址管理功能，以便于在不连续的内存空间中，部分地将进程装入。在给定时刻，一个进程镜像的一部分可能被装入内存，而其余部分则可能在辅存中。所以，进程控制表必须包含足够信息，使得操作系统可以知道进程镜像中页面的位置。一般来说，进程控制表的每个表象至少包含一个指向进程镜像的指针。如果进程镜像包含多个块，该信息会在进程控制表中记录，或者通过交叉索引在内存表格中记录。</p><p><strong>进程属性</strong></p><p>复杂的多任务系统需要为每个进程记录大量信息，这些信息可以被存储在进程控制块中。下面将会讨论操作系统到底需要进程的哪些属性信息，而不着眼于它们的组织和存储，因为不同操作系统会有自己的一套实现。</p><p>进程控制块中存放的进程信息主要由以下三个类型：</p><ul><li>进程标识符（Process Identification）；</li><li>处理器状态信息（Processor State Information）；</li><li>进程控制信息（Process Control Information）。</li></ul><p>展开来说：</p><p><strong>进程标识符</strong></p><ul><li>标识符：进程控制块中存放的进程的数字标识包含：<ul><li>该进程的标识符：操作系统在维护其他资源表格时就可以使用该标识符交叉索引进程表格。比如，在进程表格中可使用进程标识符信息来标记内存的哪些区域被分配给了哪些进程。另外，当进程需要和别的进程通信时，进程的标识符信息可以让操作系统得知参与通信的其他进程。</li><li>父进程的标识符：当操作系统允许一个进程在运行过程中创建其他进程时，该进程标识符可以用来索引父进程和子进程。</li><li>用户标识符：表征创建该进程的用户。</li></ul></li></ul><p><strong>处理器状态信息</strong>包含处理器中寄存器的值和状态。当进程执行过程中被中断时，所有的寄存器内的值将被保存到进程控制块中，以便该进程再次被调度执行时的恢复。处理器的状态信息所包含的寄存器集合在不同的处理器有着不同的定义（取决于处理器的设计），典型的有：</p><ul><li>用户可见寄存器：在用户态下程序可操纵的寄存器。</li><li>控制和状态寄存器：处理器中有一些寄存器是用来控制处理器本身的行为的，包括<ul><li>程序计数器：存储下一条即将执行的指令的地址；</li><li>条件代码：用于存储最近一条算术逻辑指令执行的结果（例如，符号标志、进位标志、是否溢出等）；<blockquote><p>一般来说，所有的处理器都包含一个或一组称为<strong>程序状态字（Program Status Word，PSW）</strong>的寄存器。这组寄存器包含了指令执行后的条件码外加一些状态信息。例如，Intel 的 x86 处理器中的 <code>EFLAGS</code> 就是一个典型的程序状态字。</p></blockquote></li><li>状态信息：包括中断是否打开、执行模式（特权级）</li></ul></li><li>栈指针：用于指向程序或操作系统所使用的栈的栈顶</li></ul><p><strong>进程控制信息</strong>被操作系统用于控制和协调系统内的各种活动进程。</p><ul><li>调度和状态信息：操作系统用于调度进程所需的信息，典型的包括如下<ul><li>进程状态：进程的当前状态（例如，运行态，就绪态等）；</li><li>优先级：一个或多个成员用于描述进程的优先级；</li><li>跟调度相关的信息：这取决于系统所使用的调度算法。这类信息的例子有进程等待时间、进程运行时间等；</li><li>事件：用于记录进程锁等待的事件</li></ul></li><li>数据组织方式：进程可能采用队列、环等数据结构与其他进程相连接。如前面提到的阻塞态队列等。</li><li>进程间通信：为了实现进程间通信，操作系统可能会在进程控制块中定义各种标志，信号，以及消息等辅助变量</li><li>进程权限：操作系统会为其中运行的进程定义各种权限，例如，它所能访问的内存范围、能够执行的指令类型，以及是否被允许使用操作系统所提供的功能和服务等</li><li>内存管理：进程控制块可能包含指向进程所包含的段描述符或页目录的指针，以描述进程在虚拟内存中的位置和状态</li><li>资源的归属和利用：进程控制块可以定义字段来描述进程所控制的资源，如打开的文件等；也可以定义字段来记录它所对应进程的被调度历史，这些信息将有助于操作系统的调度程序制定它的调度方法</li></ul><p>以上，就是一个进程控制块中存放的进程信息。进程控制块是操作系统中最重要的数据结构，每一个进程控制块都包含操作系统为了控制它所对应的进程所需要的所有重要信息。进程控制块为操作系统内几乎所有重要的模块所读取、修改，其中包括调度模块、资源分配模块、中断处理模块，以及性能监控和分析模块等。可以说，<strong>进程控制块所构成的集合直接定义了操作系统在某个时间点上的状态</strong>。</p><h2 id="4-进程控制"><a href="#4-进程控制" class="headerlink" title="4 进程控制"></a>4 进程控制</h2><p>上一节重点关注进程在操作系统中的表达，这一节的主题<strong>控制</strong>重点讲述的是进程受操作系统管理和控制时（如切换）进程的表达的变化。</p><h3 id="4-1-处理器的执行的模式"><a href="#4-1-处理器的执行的模式" class="headerlink" title="4.1 处理器的执行的模式"></a>4.1 处理器的执行的模式</h3><p>几乎所有处理器都支持两种执行模式，一种为拥有更高特权级的模式（称作内核模式），该模式下执行如读写控制寄存器、特权 I/O 指令、用于内存管理的指令；部分内存区域必须在这一模式下才能访问。另一种低特权级模式称为用户模式，用户进程往往在这一模式下执行。</p><p>之所以区分处理器执行模式，其目的在于保护操作系统以及操作系统中一些重要的表格，并将操作系统内核的操作与用户进程的操作隔离开来。出于安全的考虑，用户进程不允许拥有高权限，因为内核模式下能够执行所有指令，操纵所有寄存器和内存空间。</p><p>在实现上，处理器通过程序状态字中的特定位来标识内核/用户态，该位在一些特定事件发生时会发生转换。例如，用户态的进程在执行过程中发出了一个调用内核服务的请求，或者一个中断触发了内核中的中断服务例程的执行，这些事件发生时，处理器将切换到内核模式，而当系统从这些事件返回到用户进程后，处理器将切换回用户模式。</p><blockquote><p>书本在此处讲处理器执行模式的原因我认为是，描述清楚当前进程交出处理器控制权时会发生的事情，由于安全目的设计的两种模式，必定会出现用户栈、内核栈的区分，进而就过渡到下面在讲述进程切换时对进程“上下文”的保存与恢复工作。</p></blockquote><h3 id="4-2-进程切换"><a href="#4-2-进程切换" class="headerlink" title="4.2 进程切换"></a>4.2 进程切换</h3><p>进程切换意味着一个处于运行态的进程被中断，操作系统将另一个进程设置为运行状态，并且将处理器的控制权交给新换入的进程。下面，将关注以下问题：</p><ul><li>哪些事件触发进程切换？</li><li>处理器执行模式切换和进程切换的区别？</li><li>为了实现进程切换，操作系统需要在它的核心数据结构上做哪些操作？</li></ul><p><strong>何时进行进程切换</strong></p><p>只有当操作系统从当前运行的进程处得到了处理器的控制权后，进程切换才<strong>有可能</strong>发生。</p><p>可能导致操作系统得到处理器控制权的可能事件：</p><table><thead><tr><th align="left"><strong>机制</strong></th><th align="left"><strong>原因</strong></th><th align="left"><strong>用途</strong></th></tr></thead><tbody><tr><td align="left">硬中断</td><td align="left">外部事件的发生</td><td align="left">响应异步的外部事件</td></tr><tr><td align="left">异常（陷进）</td><td align="left">当前指令无法继续执行</td><td align="left">处理错误（如除零错误）或者异常事件（如缺页）</td></tr><tr><td align="left">系统调用</td><td align="left">用当前运行的进程显式发出</td><td align="left">调用操作系统的服务例程</td></tr></tbody></table><p>首先讲情况比较简单的情形：进程切换可能由当前进程通过显示<strong>系统调用</strong>所产生。例如，正在执行的进程通过某系统调用指令来打开文件，此时，该指令的执行将导致控制转移到操作系统的代码，操作系统将会把当前进程设置为阻塞态，而换入另一个就绪态的进程开始执行。</p><p>很多系统将中断分为两种类型：硬中断和异常。<strong>硬中断</strong>指的是与当前正在运行的进程无关的，异步产生的，独立的外部事件；<strong>异常</strong>指的是当前正在运行的进程所（同步）产生的错误，或异常事件。对于硬中断，典型的例子有时间中断，I/O 中断等，这些一般都会有固定的处理例程来处理，并在处理完后选择继续当前的进程还是下一个就绪态进程；而对于异常，操作系统还将决定判断导致该异常发生的错误或异常的状态是否是致命的。如果是致命的，当前运行的进将转移到结束态，且换入另一个进程开始执行。如果不是，操作系统的行为将取决于错误的类型和操作系统的设计原则，它可能会尝试修复错误或简单地通知用户，在这之后，操作系统将可能会继续当前进程地执行，也可能换入另一个进程开始执行。</p><p>以上就是一些可能会发生进程切换的场景，下面将会回答开头<em>进程受操作系统管理和控制时（如切换）进程的表达的变化</em>这一问题。</p><p>在处理中断时，处理器控制权首先转移到中断处理例程，然后再从中断处理例程中调用操作系统用于处理中断的函数，并最终完成对中断的处理。展开来讲就是，在指令周期的中断处理阶段，处理器会检查系统中是否有在等待还未被处理的中断，如果没有中断未被处理，处理器会进入取指阶段，取出下一条指令。如果有中断未被处理，处理器会进入以下流程：</p><ul><li>设置程序计数器到该（未被处理）中断对应的中断处理例程的入口。</li><li>从用户模式切换到内核模式，以开始中断处理例程（包括特权指令）的执行。</li></ul><p>同时，当前进程的上下文会被保存到它自己的进程控制块中。</p><blockquote><p>简单地讲，进程的上下文必须包含所有可能被中断处理例程所改变的信息，其中包括程序计数器、其他处理器寄存器，以及栈信息。</p></blockquote><p>那么在进程控制块中，除了进程上下文以外的部分在这个过程中会发生变化吗？这取决于该中断的发生是否导致了进程切换。如果中断处理后确实有进程的切换发生，则操作系统可能会做一些额外的工作（详细看后面的<strong>进程状态的改变</strong>一节），并修改当前进程的进程控制块中除了上下文以外的部分。然而，在大多数情况下，中断的发生和处理并不会直接导致进程切换。也就是说，当前进程会在中断处理历程执行完后继续执行。在这种情况下，所有需要被保存的信息就只有处理器的状态信息。通常情况下，对这些信息的保存和恢复都由硬件完成。</p><p><strong>进程状态的改变</strong></p><p>通过前面的讨论可知，处理器的模式切换并不会直接导致当前正在运行的进程被切换。在这种情况下，当前进程的上下文的保存和随后的恢复并不会带来太大的系统开销。然而，如果当前进程转移到其他状态，操作系统就必须开始一个完整的进程切换流程，包含如下步骤：</p><ul><li>保存当前进程的上下文，包括程序计数器和其他的寄存器；</li><li>改变当前进程的进程控制块的内容，其中包括其状态的改变。另外一些相关的域可能也会改变，例如离开运行态的原因、进程记账信息等；</li><li>将当前进程的控制块转移到其他队列中（例如，就绪态队列、事件 <em>i</em> 的阻塞队列、就绪且挂起态队列等）。</li><li>选择一个合适的进程开始执行，选择的动作由调度器做出。</li><li>更新被选择投入执行的进程的进程控制块，包括将其状态置为运行态。</li><li>更新内存管理模块的数据结构。</li><li>恢复被选中投入执行的进程的运行现场。</li></ul><p>所以，进程切换往往意味着进程状态的改变，相比较处理器的模式切换来说，需要更多的工作，也意味着更大的系统开销。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现代操作系统最根本的概念是进程。操作系统对进程的基本控制包括创建、管理和结束进程。当进程处于活动状态时，操作系统必须为其分配处理器时间以及其它系统资源，以及响应它们的需求。</p><p>为了对进程进行管理，操作系统必须为每个进程维护一个描述符，或者管理进程的镜像，每一个镜像都包含了进程所运行的地址空间，以及一个进程控制块。而进程控制块包含了操作系统用于控制进程所需要的所有信息，包括它的当前运行状态、所得到的资源、优先级，以及其他的相关数据。</p><p>在生命期中，进程在诸多状态中不断转换。其中，最重要的状态有就绪态、运行态和阻塞态。就绪态的进程获得了除处理器外的所有资源，运行态的进程处于正在处理器上运行的状态，在多处理器系统中，可能有多个进程同时处于运行态，阻塞态的进程正在等待某事件的发生。</p><p>处理外部异步产生的中断或处理器同步产生的异常，或者当前进程发出的系统调用，都能打断当前进程的执行。当这些发生时，处理器进行模式切换，将控制权交给操作系统的例程。而在完成这些中断处理例程或系统调用后，操作系统可能会继续当前进程的执行，也可能切换到另一个进程。</p></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2021/03/15/操作系统精髓与设计原理：线程/" rel="bookmark">操作系统精髓与设计原理：线程</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2021/04/11/计算机网络：TCP/" rel="bookmark">计算机网络：TCP（未完成草稿）</a></div></li></ul><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> kaijietti</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://kaijietti.github.io/2021/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/" title="操作系统精髓与设计原理：进程的描述与控制">https://kaijietti.github.io/2021/03/08/操作系统精髓与设计原理：进程的描述与控制/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="https://twitter.com/gohell49713918" rel="external nofollow noreferrer"><span class="icon"><i class="fab fa-twitter"></i></span> <span class="label">Twitter</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="/images/wechat_channel.png"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="fa fa-tag"></i> 操作系统</a><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 读书笔记</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2021/02/26/mdnice%E4%B8%8Ehexo%E7%9A%84%E5%85%BC%E5%AE%B9/" rel="prev" title="mdnice与hexo的兼容"><i class="fa fa-chevron-left"></i> mdnice与hexo的兼容</a></div><div class="post-nav-item"> <a href="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%EF%BC%9A%E7%BA%BF%E7%A8%8B/" rel="next" title="操作系统精髓与设计原理：线程">操作系统精髓与设计原理：线程<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6"><span class="nav-number">1.</span> <span class="nav-text">进程的描述与控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">1 什么是进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E8%83%8C%E6%99%AF"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 进程和进程控制块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">1.2.</span> <span class="nav-text">2 进程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8F%8C%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 双状态模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E4%BA%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 五状态模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E8%BF%9B%E7%A8%8B%E6%8C%82%E8%B5%B7"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 进程挂起</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">1.3.</span> <span class="nav-text">3 进程描述符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%8E%A7%E5%88%B6%E8%B5%84%E6%BA%90%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 操作系统中控制资源的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 进程控制块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">1.4.</span> <span class="nav-text">4 进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 处理器的执行的模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2 进程切换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.5.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="kaijietti" src="/images/avatar.gif"><p class="site-author-name" itemprop="name">kaijietti</p><div class="site-description" itemprop="description">专注技术分享</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">4</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/kaijietti" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kaijietti" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i></a></span><span class="links-of-author-item"><a href="mailto:guokaijie45@gmail.com" title="E-Mail → mailto:guokaijie45@gmail.com" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i></a></span><span class="links-of-author-item"><a href="https://twitter.com/gohell49713918" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;gohell49713918" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-twitter fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener external nofollow noreferrer" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">kaijietti</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">NexT.Pisces</a> 强力驱动</div><div class="busuanzi-count"><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="127,127,127" opacity="0.5" zindex="-1" count="88" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/pjax/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script src="/js/local-search.js"></script><div id="pjax"><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'oHLTTSCp8hpgowb2FC8KYc1l-gzGzoHsz',
      appKey     : 'YGQ94hekqYsjhfMzUXROg98L',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script><div class="moon-menu"><div class="moon-menu-items"><div class="moon-menu-item" onclick="back2bottom()"><i class="fas fa-chevron-down"></i></div><div class="moon-menu-item" onclick="back2top()"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script></div></body></html>