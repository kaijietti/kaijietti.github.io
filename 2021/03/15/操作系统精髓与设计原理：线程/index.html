<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><meta name="referrer" content="no-referrer"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"kaijietti.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!1,sidebar:!1,scrollpercent:!0},bookmark:{enable:!0,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!0,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!0,nav:{disqus:{text:"Load Disqus",order:-1}},activeClass:"valine"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="《操作系统精髓与设计原理》的读书摘录：线程"><meta property="og:type" content="article"><meta property="og:title" content="操作系统精髓与设计原理：线程"><meta property="og:url" content="https://kaijietti.github.io/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%EF%BC%9A%E7%BA%BF%E7%A8%8B/index.html"><meta property="og:site_name" content="GopherKai"><meta property="og:description" content="《操作系统精髓与设计原理》的读书摘录：线程"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B8.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B9.png"><meta property="article:published_time" content="2021-03-15T09:16:59.000Z"><meta property="article:modified_time" content="2021-04-11T13:39:28.385Z"><meta property="article:author" content="kaijietti"><meta property="article:tag" content="操作系统"><meta property="article:tag" content="读书笔记"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/kaijietti/image-host/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B8.png"><link rel="canonical" href="https://kaijietti.github.io/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%EF%BC%9A%E7%BA%BF%E7%A8%8B/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>操作系统精髓与设计原理：线程 | GopherKai</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">GopherKai</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">go-hell</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签<span class="badge">5</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类<span class="badge">4</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档<span class="badge">4</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/kaijietti/kaijietti.github.io" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener external nofollow noreferrer" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kaijietti.github.io/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%EF%BC%9A%E7%BA%BF%E7%A8%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="kaijietti"><meta itemprop="description" content="专注技术分享"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="GopherKai"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 操作系统精髓与设计原理：线程</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-03-15 17:16:59" itemprop="dateCreated datePublished" datetime="2021-03-15T17:16:59+08:00">2021-03-15</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-04-11 21:39:28" itemprop="dateModified" datetime="2021-04-11T21:39:28+08:00">2021-04-11</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%EF%BC%9A%E7%BA%BF%E7%A8%8B/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%EF%BC%9A%E7%BA%BF%E7%A8%8B/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>7.3k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>7 分钟</span></span><div class="post-description">《操作系统精髓与设计原理》的读书摘录：线程</div></div></header><div class="post-body" itemprop="articleBody"><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><blockquote><p>《操作系统精髓与设计原理》、《现代操作系统》读书笔记，大部分摘录自书本中</p></blockquote><h2 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1 进程和线程"></a>1 进程和线程</h2><p>之前<a target="_blank" rel="noopener external nofollow noreferrer" href="https://mp.weixin.qq.com/s/KOfByF0f_zlCFbzKrv8R8g">进程的描述与控制</a>一文中对进程的讨论主要体现了两个概念：</p><ul><li><strong>资源占用</strong>：一个进程包含了容纳进程镜像的虚地址空间（进程镜像是由进程的代码、数据、栈，以及进程控制块中所定义的各个属性所组成）。在执行过程中，进程可以申请得到对系统资源，如主存、I/O 设备和通道，以及文件等的控制权。操作系统的任务是对这些系统资源进行保护，防止进程对资源的非法访问。</li><li><strong>调度/执行</strong>：进程的执行将按照一定轨迹（Trace）进行，它的轨迹可能包含一个或多个程序的代码。如果系统中有多个进程并发执行，它们的执行轨迹将是交替向前发展的。这样，就有了进程的状态，且每个进程都要被赋予调度优先级和参与调度的实体。</li></ul><p>这两个概念在进程概念中得到了统一，但是在现代操作系统设计上，这两个概念是相互独立的。为了区分这两个概念，把进程的调度实体称为<strong>线程（Thread）</strong> 或者轻量级进程（Lightweight Process），而在考虑资源的权属上，可以把拥有资源的个体称为进程或者任务。</p><h3 id="1-1-多线程"><a href="#1-1-多线程" class="headerlink" title="1.1 多线程"></a>1.1 多线程</h3><p>多线程指的是操作系统在一个进程内支持多个并发执行路径的能力。传统的方案即单线程方案为系统中的每个进程支持一条执行路径。相反的，多线程方案支持在单个进程中的多条并发执行路径。</p><p>在多线程的环境下，进程是参与分配资源，以及权限保护的基本单位，它包含：</p><ul><li>容纳进程镜像的虚地址空间；</li><li>对处理器的受保护访问，其他进程的信息（用于进程间通信），一组文件和 I/O 资源（设备和通道）。</li></ul><p>进程可包含一个或多个线程，每个线程包含：</p><ul><li>线程的状态（运行态、就绪态等）；</li><li>线程上下文（未执行时），以及线程在进程代码中的执行位置；</li><li>私有的执行栈；</li><li>静态存储空间和局部变量；</li><li>对系统资源的访问权限。</li></ul><center><img src="https://gitee.com/kaijietti/image-host/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B8.png" width="80%/"></center><p>上图从进程管理的角度描述了进程和线程的区别。在单线程模型下（无线程概念），进程包含了进程控制块、用户态地址空间，以及用于函数调用的用户态和内核态栈。在多线程环境下，进程仍然具有它的进程控制块，以及用户态地址空间，但它的每个线程都拥有自己的私有执行栈，而且每个线程都有自己的控制块以存放上下文、优先级，以及线程状态信息。</p><p>这样，进程的线程共享它们的父进程的状态，以及它所拥有的系统资源，且它们共存于同一地址空间，访问同一组数据。如果当其中的一个线程更改了内存中的数据，该进程的其他线线程就能看到这一更改，同理，如果某进程的一个线程在执行过程中采用了只读权限打开了某文件，该进程的其他线程将能够看到这个被打开的文件，且都有从该文件中读取的权限。</p><p>线程概念的产生，实际上是对计算机系统的性能进行优化的结果：</p><ul><li>相比于创建一个新进程而言，在现有的进程基础上创建一个线程将要快得多；</li><li>相比于结束一个进程而言，结束一个线程要快得多；</li><li>在同一个进程的不同线程间切换，要比在不同的进程间切换要快得多；</li><li>线程间通信要比进程间通信快得多。在大多数操作系统中，进程间通信往往需要内核的参与，然而对于属于同一个进程的线程而言，因为它们共享进程的内存及打开的文件，它们之间的通信就不需要借助内核来进行。</li></ul><blockquote><p>即使在单处理器上，线程的结构一样可以被用来在一个程序中构造和区分逻辑上独立的功能，实现如前台/背景工作、异步处理、提高执行速度、模块化程序设计等的功能。</p></blockquote><p>在支持线程的操作系统中，调度往往基于线程来执行。因此，大多数有关执行的状态信息都保存在线程级的数据结构中。然而，有一些影响到一个进程所有线程的动作必须在进程的级别处理。例如，进程挂起操作需要将进程的地址空间整体换出到磁盘上，从而为其他进程的执行腾出主存空间。同时，由于进程的所有线程都共享其父进程的地址空间，所有进程的挂起操作将导致它所有的线程被同时挂起。同理，进程的结束将导致它所有的线程一起结束。</p><h3 id="1-2-线程功能"><a href="#1-2-线程功能" class="headerlink" title="1.2 线程功能"></a>1.2 线程功能</h3><blockquote><p>书本此处简要地对线程状态和线程同步进行介绍，原因在于，在线程状态设计上，不同操作系统会有不同的设计；而在线程同步上，涉及的相关机制繁多，故单独成章讨论。</p></blockquote><p><strong>线程状态</strong></p><p>类似于进程，线程的基本状态是运行态、就绪态，以及阻塞态。一般来说，挂起态对于线程来说是没有意义的，因为这一状态是进程级别的概念。如果进程被换出到磁盘，它所有的线程必然都被换出，因为它们都共享父进程的地址空间。</p><p>导致线程状态发生变化的 4 个基本操作如下：</p><ul><li><strong>创建（Spawn）</strong>：一般来说，一个新进程被创建的同时，它对应的一个线程也会被创建。其后，进程可以通过给出入口地址和参数，创建另一个线程（可以联想 Pthread 库的 API）。新创建的线程将拥有自己的寄存器上下文，以及私有栈空间，且进入就绪队列。</li><li><strong>阻塞（Block）</strong>：当线程等待某事件的发生才能继续执行时，它将进入阻塞态（保存它的用户级寄存、记录执行地址和栈指针等到线程上下文中）。处理器在其后转而执行下一个处于就绪态的线程。</li><li><strong>唤醒（Unblock）</strong>：如果线程所等待的事件发生，该线程将进入就绪队列。</li><li><strong>结束（Finish）</strong>：当线程执行完毕后，它所对应的寄存器上下文及私有栈资源将被系统回收。</li></ul><p><strong>线程同步</strong></p><p>一个进程的所有线程共享该进程的地址空间，以及它所拥有的系统资源。这样，一个线程对系统资源的任何改变都将影响到属于该进程的所有其他线程所运行的环境。为了保证程序的正确执行，需要对线程的活动加以协调和同步，使得它们不会互相干扰或者破坏重要的全局数据结构。</p><blockquote><p>实际上，用于线程同步的方法和机制与用于进程同步的方法和机制是一样的，将在<strong>并发：互斥与同步</strong>及<strong>并发：死锁与饥饿</strong>章节进一步讨论。</p></blockquote><h2 id="2-线程的类型"><a href="#2-线程的类型" class="headerlink" title="2 线程的类型"></a>2 线程的类型</h2><p>线程的实现可粗略分为两种：<strong>用户级线程（User-Level Threads，ULTs）</strong>和<strong>内核级线程（Kernel-Level Threads，KLTs）</strong>。</p><center><img src="https://gitee.com/kaijietti/image-host/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B9.png" width="80%" alt="线程类型"></center><h3 id="2-1-用户级线程"><a href="#2-1-用户级线程" class="headerlink" title="2.1 用户级线程"></a>2.1 用户级线程</h3><p>在纯用户级线程的设计中，所有线程管理的工作都用应用程序（进程）自己完成。内核甚至不知道线程的存在。在一个典型的用户级线程的设计，线程库提供了用于创建线程、销毁、调度（包括线程寄存器上下文的保存），甚至线程间消息和数据通信的接口。应用可以使用线程库，设计自己的多个线程。在缺省情况下，应用程序开始执行时只有一个线程，而操作系统将该线程作为单个进程加以调度。在该应用进程运行的过程中（运行态），它可以调用线程库中的例程来创建新的线程在其地址空间中运行。在进程调用线程库的时候，线程库为被创建的线程建立起用于管理的数据结构（如线程控制块），并在其后根据自己的调度算法，将控制交给进程中处于就绪态的线程继续执行。在这些动作之前，线程库需要保存进程中处于运行态的线程的上下文信息，而在将控制权交给新的就绪态线程时，恢复该进程的上下文。这里所说的线程上下文主要包括用户态寄存器、程序计数器，以及栈指针。</p><p>线程库的行为都发生在进程内且都在用户态执行，操作系统无法感知。所以对于操作系统来说，它还是将进程作为一整个实体加以调度，且为其执行赋予唯一的状态（如就绪态、运行态，而这些并不能区分内部线程状态）。所以说，当进程内多个线程中的某个线程调用了一个系统调用（如 I/O 操作），控制首先转移到操作系统内核，而内核因为 I/O 操作需要等待结果的返回，将该进程设置为阻塞态，并切换到另一个就绪态进程开始执行。那么，即便在该进程的视角看（即线程库的角度）其他线程是运行态，但实质上并不在处理器上执行。</p><p><strong>与内核级线程方案相比较，采用用户级线程的方案具有以下优点</strong></p><ul><li>由于用于管理线程的数据结构都保存在进程的用户态地址空间，线程切换无需内核态的权限，所以线程切换不需要陷入内核态以完成所有的管理工作，从而避免了两次模式切换的开销（从用户态到内核态，再从内核态回到用户态）。</li><li>线程调度可由应用定制。应用程序可以按照自己的需要定制线程调度算法，而无需破坏或受制于操作系统的调度算法。</li><li>用户级线程可运行在任何操作系统上。这样，就无需为了支持多线程而修改操作系统的代码，且用户级线程库的设计可在多个用户态程序中得到应用。</li></ul><p><strong>相比较下的缺点</strong></p><ul><li>在典型的操作系统设计中，许多系统调用都会导致调用它们的进程阻塞。所以，如果用户级线程调用了这些系统调用，它将不仅导致线程自己的阻塞，也将导致它所属的进程的所有线程阻塞。除了会导致阻塞的系统调用外，页错误的处理也会发生类似的情况。</li><li>在纯用户级线程的设计方案中，多线程的应用无法利用系统中的多处理器资源，这是因为操作系统一次只会将一个进程调度到一个处理器上执行。所以，进程一次只有一个线程能够执行。</li><li>当某线程处于运行态时，除非它自愿让出处理器，否则它的所属进程的其他线程将没有机会得到运行机会。在进程内没有时钟中断，所以不可能实现轮询调度，除非线程自己进入运行时系统（应用线程库），否则调度器没有机会执行调度算法。<blockquote><p>一个可能的解决方法是让运行时系统请求一定时间间隔的时钟信号从而将控制权移交给运行时系统。但过高频率的中断信号不切实际，而且即便采用了，开销也会很大。</p></blockquote></li></ul><p>避免线程阻塞的一个办法是护套（Jacketing）技术，该技术的目标是将导致阻塞的系统调用转换为非阻塞的系统调用。例如，将线程对操作系统 I/O 例程的直接调用转换为一个（非阻塞的）应用级 I/O 护套调用，后者检测 I/O 设备是否被占用。如果被占用，线程将进入阻塞态，并将处理器控制权（通过线程库）转移给同一进程的另一个线程。当该线程被再次调入执行时，它将再次调用护套调用检测 I/O 设备的情况。</p><h3 id="2-2-内核级线程"><a href="#2-2-内核级线程" class="headerlink" title="2.2 内核级线程"></a>2.2 内核级线程</h3><p>在纯内核级线程的设计方案中，所有线程的管理功能都由操作系统内核来完成。用户态中没有关于线程管理的代码，只有程序设计接口（API）。操作系统内核管理和维护所有进程及进程中的线程的上下文信息，同时，内核的调度算法基于系统中线程的信息。这个方案克服了用户级线程设计方案的两个缺点：首先，内核能够将同属于一个进程的多个线程同时调度到多个处理器上执行；其次，如果某进程的一个线程被阻塞，内核仍然能够调度该进程的其他线程到处理器上执行。</p><p>当进程需要创建或销毁进程时，它需要调用对应的系统调用从而由操作系统来代替创建和销毁，所以进程内不需要有相关的运行时系统（应用线程库）。由于内核态下执行创建和销毁的开销很大，一些系统也会利用线程复用技术，当线程被销毁时，只是将其标记为不可执行，而核心的数据结构仍然保持。当某进程需要创建线程时，将该线程重新激活，就能够节省创建和销毁线程的大部分开销。</p><p><strong>相比于用户级线程方案，内核级线程方案的最大缺点在于</strong>即使是同一进程的不同线程间切换，都会导致用户态到内核态的模式切换。除此之外还有一些设计问题，比如，多线程的进程调用 <code>fork</code> 时会发生什么，是创建和原进程一样多的线程，还是只创建一个线程？这取决于程序上下文，每个选择都是对应某个场景。</p><p>书本数据（此处不列出因为结论比较普遍）表明，相比于独立进程，采用内核级线程的设计方案可以带来很大的性能提升，如果采用用户级线程的设计方案，则可获得更大的性能提升。然而，是否能获得性能上的提升，最终取决于应用本身的特点。例如，如果某进程的线程中存在大量的内核模式的访问（如系统调用），则用户级线程设计方案不见得会比内核级线程设计方案带来更多的性能提升。</p><h3 id="2-3-混合设计"><a href="#2-3-混合设计" class="headerlink" title="2.3 混合设计"></a>2.3 混合设计</h3><p>一些操作系统提供混合用户级线程和内核级线程的设计方案，在该方案中，线程的创建、调度和同步完全在用户态完成。同时，进程的多个线程可以映射到一组（数量相同或更少）内核态线程上。于是，程序员能够根据应用特点和系统中拥有处理器的数量，通过调整内核级线程的数量来优化系统整体的性能。</p><p>在混合设计方案中，同一应用的多个线程能够同时运行在系统的多个处理器上，且某线程的阻塞不会导致整个进程的阻塞。如果调整得当，这一方案能够综合用户级线程和内核级线程方案的优点并最小化它们的缺点。</p><h2 id="3-Linux-的进程-线程管理"><a href="#3-Linux-的进程-线程管理" class="headerlink" title="3 Linux 的进程/线程管理"></a>3 Linux 的进程/线程管理</h2><blockquote><p>书本此处对于 Linux 下的进程状态转换图描述并不够详尽，所以下面注重于 Linux 下的线程实现。</p></blockquote><p>在 Linux 中，进程（也称为任务）由 task_struct 数据结构所描述，该结构包含了进程在各方面的定义，如状态信息、调度信息，地址空间等等。</p><h3 id="3-1-Linux-线程"><a href="#3-1-Linux-线程" class="headerlink" title="3.1 Linux 线程"></a>3.1 Linux 线程</h3><p>传统 UNIX 系统只支持单线程进程，而最新的 UNIX 系统支持多内核线程的进程。早期版本的 Linux 内核遵循传统 UNIX 标准，所以不提供多线程支持。然而作为折衷，应用程序可以调用用户级的线程库实现并发执行路径，如著名的线程库 Pthread，它的实现原理是，将应用创建的线程（通过调用 Pthread 提供的 API）映射到单个内核态的进程。虽然最新的 UNIX 支持多内核线程，Linux 系统给出独特的设计：不区分线程和进程的区别，而是将用户级线程映射到内核级进程上。属于同一进程的线程被映射到一组拥有相同组 ID 的内核级进程上，这样就可以使这些内核级进程拥有相同的共享资源（如内存资源和打开的文件等），且当调度在组内的进程间执行时，无需切换进程上下文，从而减轻调度开销。</p><p>Linux 系统定义了 <code>clone()</code> 这一系统调用来实现该目标：通过该系统调用所创建的新进程拥有与父进程相同的资源，如文件、信号表和虚拟内存空间。实际上，当两个进程拥有相同的虚拟内存，它们就等同于同一个进程的两个线程了，而无需专门为了实现线程而定义额外的数据结构。Linux 内核从一个进程切换到另一个时，会比较两者的页目录是否相同，如果相同，则说明这两个进程共享了地址空间，这时，进程切换就无需装载新的进程上下文，切换动作就等同于在同一个进程内发生的跳转指令。然而需要注意的是，虽然通过 clone() 系统调用创建的一组进程共享地址空间，但它们却不能共享用户态栈，因为每个进程都会有自己独立的执行路径（使用不同的参数调用不同的函数会用到栈空间）。这样，clone() 系统调用必须为它所创建的每个进程分配独立的用户态栈。</p><h3 id="3-2-Linux-命名空间"><a href="#3-2-Linux-命名空间" class="headerlink" title="3.2 Linux 命名空间"></a>3.2 Linux 命名空间</h3><p>每个 Linux 进程都可以定义一组命名空间，这一组命名空间的作用是，让拥有特定命名空间的进程具有与其他拥有不同命名空间的进程不同的系统视图。也就是说，命名空间定义了进程所运行的系统的状态。命名空间的一个重要作用就是实现控制组（Cgroup）的概念，而控制组的概念是实现轻量级虚拟化的重要组成部分，它可以为一个或一组进程构造只有它（们）在系统中独立运行的假象。</p><p>Linux 为进程定义了 6 种类型的命名空间：MNT、PID、NET、IPC、UTS 和 USER。通过调用 clone() 并传入适当标志（CLONE_NEWNS、CLONE_NEWPID、CLONE_NEWNET、CLONE_NEWIPC、CLONE_NEWUTS，以及CLONE_NEWUSER），进程可以创建与其父进程不同的命名空间。另外，进程也可以在运行过程中通过调用 unshare() 系统调用动态创建新的命名空间。</p><p><strong>挂载命名空间（Mount Namespace）</strong>：该命名空间定义了进程所看到的文件系统结构，拥有不同挂载命名空间的进程所看到的文件系统是不同的。进程对文件的操作被局限在自己的挂载命名空间内。</p><p><strong>UTS（UNIX Timesharing）命名空间</strong>：该命名空间与 uname() 系统调用相关。uname() 系统调用返回当前内核的名字信息，其中包含了节点名以及域名。而域名又是 UNIX 世界中广泛采用的网络信息服务（Network Information Service，NIS）系统的标识，这就允许拥有相同 UTS 命名空间，但不在同一台物理机器上的进程共享相同的配置参数。同时，也可以让在同一台物理机器上，但拥有不同 UTS 命名空间的进程使用不同的配置参数。</p><p><strong>进程间通信（IPC）命名空间</strong>：该命名空间可以隔离用于进程间通信的资源，例如，信号量等。同样，程序员可以为拥有相同 IPC 命名空间的进程指定它们之间的同步机制。</p><p><strong>进程标识（PID）命名空间</strong>：该命名空间用于隔离进程标识命名空间。不同 PID 命名空间的进程可以拥有相同的进程标识。这一特性使得在用户态进行的检查点和恢复机制（Checkpoint/Restore In Userspace，CRIU）成为可能。该机制允许在某检查点，对一个（或一组）正在运行的进程进行快照，并将快照保存在一个或多个文件中。这样，用户用这些文件在其后恢复进程时，从最近的检查点处开始，而无需担心它（或它们中的某一个进程）与系统的其他进程拥有相同的进程标识，从而导致冲突。</p><p><strong>网络（NET）命名空间</strong>：该命名空间将系统中与网络有关的资源进行隔离，每个网络空间都有自己的网络设备、IP 地址、IP 路由表、端口号等。这些网络命名空间对网络访问进行了虚拟化，从而允许每个控制组拥有它所需要的网络访问方式。然而，对于单个的物理设备和网络设备，它在任一时刻只属于一个网络命名空间。同理，一个网络套接字只属于一个网络命名空间。</p><p><strong>用户（USER）命名空间</strong>：一个用户命名空间可以看作是一个容器，它包含自己的用户标识集合，该集合甚至可以完全独立于父进程，以及所运行的系统。这样，当一个进程调用 clone() 创建子进程时，可以为该子进程分配新的用户命名空间、新的进程标识空间，以及其他命名空间。使得对于父进程所分配给它的那部分资源，子进程能够拥有与其父进程同等的权限。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>很多操作系统对进程和线程的概念进行了区分，一般来说，进程主要涉及资源管理权限问题，而线程主要与程序的执行相关。在一个支持多线程的系统中，一个进程可以定义多个并发线程以提高执行速度或系统资源利用率。实现的方法有用户级线程和内核级线程两种。用户级线程的创建和管理是通过在用户态调用线程库的方法，操作系统一般无法感知用户级线程的存在。相比于内核级线程，用户级线程往往更加高效，这是因为它的切换无需处理器的模式切换。然而，它的缺点在于：在单个进程中，一次只能执行一个用户级线程，且如果一个用户级线程阻塞，整个进程都将阻塞。相反，内核级线程的状态信息由操作系统内核来管理，同一个进程的多个内核级线程能够在多个处理器上并行地执行，且单个线程的阻塞不会导致整个进程的阻塞。内核级线程的缺陷，在于它的切换会导致处理器的模式切换开销。</p></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2021/03/08/操作系统精髓与设计原理：进程的描述与控制/" rel="bookmark">操作系统精髓与设计原理：进程的描述与控制</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2021/04/11/计算机网络：TCP/" rel="bookmark">计算机网络：TCP（未完成草稿）</a></div></li></ul><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> kaijietti</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://kaijietti.github.io/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%EF%BC%9A%E7%BA%BF%E7%A8%8B/" title="操作系统精髓与设计原理：线程">https://kaijietti.github.io/2021/03/15/操作系统精髓与设计原理：线程/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="https://twitter.com/gohell49713918" rel="external nofollow noreferrer"><span class="icon"><i class="fab fa-twitter"></i></span> <span class="label">Twitter</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="/images/wechat_channel.png"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="fa fa-tag"></i> 操作系统</a><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 读书笔记</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2021/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/" rel="prev" title="操作系统精髓与设计原理：进程的描述与控制"><i class="fa fa-chevron-left"></i> 操作系统精髓与设计原理：进程的描述与控制</a></div><div class="post-nav-item"> <a href="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9ATCP/" rel="next" title="计算机网络：TCP（未完成草稿）">计算机网络：TCP（未完成草稿）<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">1 进程和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E7%BA%BF%E7%A8%8B%E5%8A%9F%E8%83%BD"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 线程功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">2 线程的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 用户级线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 内核级线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%B7%B7%E5%90%88%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 混合设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Linux-%E7%9A%84%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">3 Linux 的进程&#x2F;线程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Linux-%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 Linux 线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Linux-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 Linux 命名空间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%80%BB%E7%BB%93"><span class="nav-number">1.4.</span> <span class="nav-text">4 总结</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="kaijietti" src="/images/avatar.gif"><p class="site-author-name" itemprop="name">kaijietti</p><div class="site-description" itemprop="description">专注技术分享</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">4</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/kaijietti" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kaijietti" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i></a></span><span class="links-of-author-item"><a href="mailto:guokaijie45@gmail.com" title="E-Mail → mailto:guokaijie45@gmail.com" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i></a></span><span class="links-of-author-item"><a href="https://twitter.com/gohell49713918" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;gohell49713918" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-twitter fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener external nofollow noreferrer" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">kaijietti</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">NexT.Pisces</a> 强力驱动</div><div class="busuanzi-count"><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="127,127,127" opacity="0.5" zindex="-1" count="88" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/pjax/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script src="/js/local-search.js"></script><div id="pjax"><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'oHLTTSCp8hpgowb2FC8KYc1l-gzGzoHsz',
      appKey     : 'YGQ94hekqYsjhfMzUXROg98L',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script><div class="moon-menu"><div class="moon-menu-items"><div class="moon-menu-item" onclick="back2bottom()"><i class="fas fa-chevron-down"></i></div><div class="moon-menu-item" onclick="back2top()"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script></div></body></html>