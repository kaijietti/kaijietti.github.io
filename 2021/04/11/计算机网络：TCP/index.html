<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><meta name="referrer" content="no-referrer"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"kaijietti.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!1,sidebar:!1,scrollpercent:!0},bookmark:{enable:!0,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!0,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!0,nav:{disqus:{text:"Load Disqus",order:-1}},activeClass:"valine"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="计算机网络的读书摘录：TCP"><meta property="og:type" content="article"><meta property="og:title" content="计算机网络：TCP（未完成草稿）"><meta property="og:url" content="https://kaijietti.github.io/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9ATCP/index.html"><meta property="og:site_name" content="GopherKai"><meta property="og:description" content="计算机网络的读书摘录：TCP"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210408154117.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210327145451.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210327231738.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210328150353.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210329141326.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210329141853.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210329142126.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210329160755.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210329160944.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210323155224.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210323155224.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210323191139.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210323191139.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210323195001.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210323195001.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210324184523.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210324170522.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210324172839.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210324173815.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210405194723.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210405212721.png"><meta property="og:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210405220039.png"><meta property="article:published_time" content="2021-04-11T09:16:59.000Z"><meta property="article:modified_time" content="2021-04-11T13:39:28.385Z"><meta property="article:author" content="kaijietti"><meta property="article:tag" content="读书笔记"><meta property="article:tag" content="计算机网络"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/kaijietti/image-host/raw/master/20210408154117.png"><link rel="canonical" href="https://kaijietti.github.io/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9ATCP/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>计算机网络：TCP（未完成草稿） | GopherKai</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">GopherKai</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">go-hell</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签<span class="badge">5</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类<span class="badge">4</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档<span class="badge">4</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/kaijietti/kaijietti.github.io" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener external nofollow noreferrer" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kaijietti.github.io/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9ATCP/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="kaijietti"><meta itemprop="description" content="专注技术分享"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="GopherKai"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 计算机网络：TCP（未完成草稿）</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-04-11 17:16:59 / 修改时间：21:39:28" itemprop="dateCreated datePublished" datetime="2021-04-11T17:16:59+08:00">2021-04-11</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9ATCP/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9ATCP/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>15k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>13 分钟</span></span><div class="post-description">计算机网络的读书摘录：TCP</div></div></header><div class="post-body" itemprop="articleBody"><h1 id="可靠的面向连接的传输：TCP"><a href="#可靠的面向连接的传输：TCP" class="headerlink" title="可靠的面向连接的传输：TCP"></a>可靠的面向连接的传输：TCP</h1><blockquote><p>主要整理自《计算机网络（第7版）谢希仁编著》、《计算机网络：一种开源的设计实现方法》、《计算机网络：系统方法》，在下文分别称为谢书、林书和拉书。</p></blockquote><p>[toc]</p><h2 id="1-连接管理"><a href="#1-连接管理" class="headerlink" title="1 连接管理"></a>1 连接管理</h2><h3 id="1-0-有限状态机"><a href="#1-0-有限状态机" class="headerlink" title="1.0 有限状态机"></a>1.0 有限状态机</h3><p><img src="https://gitee.com/kaijietti/image-host/raw/master/20210408154117.png" alt="TCP 状态转换图"></p><h3 id="1-1-连接建立"><a href="#1-1-连接建立" class="headerlink" title="1.1 连接建立"></a>1.1 连接建立</h3><p><strong>常见问题</strong></p><ul><li>三报文握手过程中，如果某次握手信息丢失会怎样？</li><li>为什么要进行三报文握手，两报文可以吗？</li><li>三报文握手存在的问题？<ul><li>SYN FLOOD 是什么？</li></ul></li></ul><h3 id="1-2-连接释放"><a href="#1-2-连接释放" class="headerlink" title="1.2 连接释放"></a>1.2 连接释放</h3><p><strong>常见问题</strong></p><ul><li>为什么要四报文挥手？</li><li>CLOSE-WAIT 和 TIME-WAIT 的状态和意义</li><li>TIME-WAIT 状态会导致什么问题？</li><li>TIME-WAIT 状态为什么必须等待 2MSL 的时间？</li></ul><h3 id="1-3-分组消耗序列号的问题"><a href="#1-3-分组消耗序列号的问题" class="headerlink" title="1.3 分组消耗序列号的问题"></a>1.3 分组消耗序列号的问题</h3><blockquote><p>这里总结一下各种报文段对序列号消耗的问题以及原因。比如 pure ACK 不消耗且不被 ACKed，RST 不需要被ACKed，等等。<br>基本上是否被 ACKed 与 是否消耗序列号等同。</p></blockquote><p>RST 并不需要被 ACK 但可以携带数据：<br>RFC 1122：<br>A TCP SHOULD allow a received RST segment to include data.<br>DISCUSSION<br> It has been suggested that a RST segment could contain<br> ASCII text that encoded and explained the cause of the<br> RST. No standard has yet been established for such<br> data.</p><h3 id="1-4-连接状态与套接字-API-的关系"><a href="#1-4-连接状态与套接字-API-的关系" class="headerlink" title="1.4 连接状态与套接字 API 的关系"></a>1.4 连接状态与套接字 API 的关系</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/yunhua_lee/article/details/40513677?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control&amp;dist_request_id=1328690.20886.16166497340647521&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control">https://blog.csdn.net/yunhua_lee/article/details/40513677?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-5.control&amp;dist_request_id=1328690.20886.16166497340647521&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-5.control</a></p><h2 id="2-数据传输的可靠性"><a href="#2-数据传输的可靠性" class="headerlink" title="2 数据传输的可靠性"></a>2 数据传输的可靠性</h2><blockquote><p>注意，书上可靠性仅关注数据的可靠传输和有序到达。流量控制和拥塞控制归属于速率控制，是建立在可靠性基础上的机制。</p></blockquote><h3 id="2-1-分段的差错控制：校验和"><a href="#2-1-分段的差错控制：校验和" class="headerlink" title="2.1 分段的差错控制：校验和"></a>2.1 分段的差错控制：校验和</h3><p>TCP 校验和与 UDP 校验和计算方式是一样的，但前者是强制性的，后者是可选的。对比于以太网中使用 32 位的循环冗余校验和，传输层协议的校验和是相对较弱的检查。除此之外关于检验和的细节就是<em>伪头部</em>，其作用就是防止处理路由错误到达的分组。</p><blockquote><p>TCP 检验和相关的部分不是本文重点，可以参考以下链接：<br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://tools.ietf.org/html/rfc793#section-3.1">https://tools.ietf.org/html/rfc793#section-3.1</a><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikibooks.org/wiki/Communication_Networks/TCP_and_UDP_Protocols/UDP#Checksum_Calculation">https://en.wikibooks.org/wiki/Communication_Networks/TCP_and_UDP_Protocols/UDP#Checksum_Calculation</a><br><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.tcpipguide.com/free/t_TCPChecksumCalculationandtheTCPPseudoHeader-2.htm">http://www.tcpipguide.com/free/t_TCPChecksumCalculationandtheTCPPseudoHeader-2.htm</a></p></blockquote><h3 id="2-2-流的可靠性：序列号和确认应答"><a href="#2-2-流的可靠性：序列号和确认应答" class="headerlink" title="2.2 流的可靠性：序列号和确认应答"></a>2.2 流的可靠性：序列号和确认应答</h3><p>每个分段的校验和不足以保证可靠地和按序地发送全部分组化的数据。由于分组的数据偶尔也会在互联网上丢失，所以必须有一种机制来重传丢失的分组。而且，因为按顺序发送的分组由于互联网路由的无状态性质可能会不按顺序接收，所以必须提供另外一种机制重新排列无序的分组。这两种机制分别依赖于<strong>确认应答（ACK）和序列号</strong>。</p><p>从理论上，给每个字节数据分配一个序列号。然后，一个分组的序列号表示它的第一个数据字节的序列号，存储在 TCP 头部的 32 位序列号字段。TCP 发送者进行编号并且跟踪已经发送的数据字节并等待它们的确认。一旦收到一个数据分组，TCP 接收者就回应一个 ACK 分组，该分组携带的确认号表示在指定确认号以前的数据字节已经成功接收（或者说是期望接收的下一个数据分组的序列号）。</p><p>TCP 接收方一般都是采用累积 ACK 的方式，即不必对收到的分组逐个发送确认，而是在收到若干个分组后，对按序到达的最后一个分组发送确认。</p><p>进一步的，还需要考虑 TCP 如何高效发送数据（下文的滑动窗口）、有效处理丢失或者异常事件（使用定时器等等）以及如何协调收发双方行为等等，这些都在后文讨论。</p><h3 id="2-3-异常情况"><a href="#2-3-异常情况" class="headerlink" title="2.3 异常情况"></a>2.3 异常情况</h3><p><img src="https://gitee.com/kaijietti/image-host/raw/master/20210327145451.png" alt="TCP 可靠性"></p><p>对应的解释：</p><ul><li>如图 a 表示，数据丢失的情况下，在重传定时器超时后发送者就会察觉到这种丢失并重传丢失的分组。</li><li>如图 b 表示，大的传播延迟可能会导致过早超时，导致不必要的重传。此时接收方将重传分组仅作为重复数据而丢弃。可靠性虽然得到保证但若经常出现这种情况将会严重浪费带宽。</li><li>如图 c 表示，TCP 使用累计 ACK 的优点之一就是：前面的 ACK 的丢失不会造成任何不必要的数据重传，因为随后的 ACK 会重复丢失 ACK 中的确认信息。</li><li>如图 d 表示，TCP 使用累积 ACK 会出现重复 ACK 的情况，给发送方感觉分组丢失了，但当数据最后按序排列时，累积 ACK 同样能返回期待的确认号。</li></ul><h2 id="3-流量控制"><a href="#3-流量控制" class="headerlink" title="3 流量控制"></a>3 流量控制</h2><blockquote><p>本节内容是对前一节可靠传输的进一步讨论。</p></blockquote><p>使用确认和超时实现可靠传输的策略称为<em>自动请求重发（Automatic Repeat Request，ARQ）</em> ，有三种不同的 ARQ 算法：</p><ul><li>停止-等待（stop-and-wait）协议</li><li>滑动窗口（TCP 采用的算法基础）</li><li>并发逻辑信道</li></ul><blockquote><p>拉书注：延迟带宽积的重要性在于，它表示可传输的数据总量。我们希望不等待第一个确认而能够发送这么多的数据，这里使用的原理通常称为保持管道满载（keeping the pipe full）。</p></blockquote><h3 id="3-1-滑动窗口"><a href="#3-1-滑动窗口" class="headerlink" title="3.1 滑动窗口"></a>3.1 滑动窗口</h3><p>拉书对于滑动窗口的探讨比较深入，值得精读。</p><p><strong>滑动窗口算法</strong>的工作过程如下：</p><p>首先，发送方对每一帧赋予一个序号（sequence number），记作 SeqNum（暂时忽略 SeqNum 是由有限大小的首部字段实现的事实）。</p><p><em>发送方</em>维护三个变量：</p><ul><li>发送窗口大小（send window size，SWS），给出发送方能够发送但未确认的帧数的上界。</li><li>最近收到的确认帧（last acknowledgement received，LAR）的序号。</li><li>最近发送的帧（last frame sent，LFS）的序号。</li></ul><p>遵循如下不等式（<code>LFS - LAR &lt;= SWS</code>）：</p><p><img src="https://gitee.com/kaijietti/image-host/raw/master/20210327231738.png" alt="发送方的滑动窗口"></p><p>当确认到达时，发送方向右移动 LAR，从而允许发送方发送另一帧。同时，发送方为所发的每一帧设置一个定时器，如果定时器在接收到 ACK 之前超时，则重传此帧。注意，发送方必须缓存多达 SWS 个帧，因为在它们得到确认之前必须准备重传。</p><p><em>接收方</em>维护三个变量：</p><ul><li>接收窗口大小（receive windown size，RWS），给出接收方所能接收的无序帧数目的上界。</li><li>最大可接收帧（largest acceptable frame，LAF）的序号。</li><li>最后收到的帧（last received frame，LRF）的序号。</li></ul><p>遵循如下不等式（<code>LAF - LFR &lt;= RWS</code>）：</p><p><img src="https://gitee.com/kaijietti/image-host/raw/master/20210328150353.png" alt="接收方的滑动窗口"></p><p>当一个具有序号 SeqNum 的帧到达时，接收方采取如下行动：</p><ul><li>如果 <code>SeqNum &lt;= LFR</code> 或 <code>SeqNum &gt; LAF</code>，那么帧不在接收方窗口内，于是丢弃。</li><li>如果 <code>LFR &lt; SeqNum &lt;= LAF</code>，那么帧在接收窗口内，于是接收。</li></ul><p>现在接收方决定是否发送 ACK。令 SeqNumToACK 表示未被确认帧的最大序号（意味着序号小于等于 SeqNumToACK 的帧都已收到），即使已经收到更高序号的分组，接收方仍确认 SeqNumToACK 的接收（即累积确认）。然后，设 LFR = SeqNumToACK，并调整 LAF = LFR + RWS。</p><p>在考虑分组丢失重传效率的问题上，解决方法有很多，如 NACK，重复ACK（立即发送确认即便错序）以及 SACK（选择性 ACK）。其中，NACK 增加了接收方的复杂性（因此不推荐这样做），重复 ACK 能够作为帧丢失的线索从而能够尽早检测分组的丢失，SACK 则用于解决后面 TCP Reno 的多分组丢失问题。这些解决方法的思路就是给发送方提供更多信息，从而使其较容易地保持管道满载。</p><p>另外，接收方的 RWS 设置为任何想要的值：</p><ul><li>RWS = 1，表示接收方不缓存任何错序到达的帧；</li><li>RWS = SWS，表示接收方能够缓存发送方传输的任何帧；</li><li>RWS &gt; sws，此设置无意义，因为错误到达的帧树木不可能超过 SWS。</li></ul><p><strong>有限序号</strong></p><p>实际上，帧的序号由大小有限的首部字段来说明，那么序号就会回绕。这就带来了一个问题：要能够区别同一序号体现的不同帧，这意味着可用序号的数目必须大于所允许的待确认帧的数目。</p><p>拉书上有关于 MaxSeqNum（可用序列号总数） 与 RWS、SWS 的关系探讨，这里给出其习题：</p><p><img src="https://gitee.com/kaijietti/image-host/raw/master/20210329141326.png" alt="MaxSeqNum &lt; RWS + SWS 时可能出现的错误情况"></p><p><img src="https://gitee.com/kaijietti/image-host/raw/master/20210329141853.png" alt="MexSeqNum = RWS + SWS 时恰好足够使用的临界情况"></p><p><img src="https://gitee.com/kaijietti/image-host/raw/master/20210329142126.png" alt="RWS 与 SWS 不等时，MaxSeqNum 与其的一般关系式"></p><blockquote><p>第二张图中说明的按序到达的条件是比较理想化的，现实中在普通情况下不太可能遇到回绕问题，但高速链路上或者跨连接的分组仍然可能造成异常，这就需要进一步解决了。</p></blockquote><h3 id="3-2-TCP-滑动窗口算法"><a href="#3-2-TCP-滑动窗口算法" class="headerlink" title="3.2 TCP 滑动窗口算法"></a>3.2 TCP 滑动窗口算法</h3><p>TCP 滑动窗口算法三个功能：</p><ul><li>数据的可靠传递</li><li>数据的有序传递</li><li>发送方和接收方之间的流量控制</li></ul><p>前两个功能与前面的基本滑动窗口算法类似，但 TCP 并不使用固定尺寸的滑动窗口，而是由接收方向发送方通知（advertise）它的窗口尺寸。这是通过使用 TCP 首部的 AdvertisedWindow 字段完成的。接收方基于自己的缓冲区大小和数据处理速率来设定接收窗口值，并通过对发送方数据的确认的首部字段携带窗口值。这就是流量控制的基本原理了。如有其他细节后续会补充。</p><p>拉书进一步描述了 TCP 首部的 SequenceNum 和 AdvertisedWindow 字段对正确新和性能的影响。TCP 的 SequenceNum 字段长 32 位，AdvertisedWindow 字段长 16 位，也就是说 TCP 已经满足滑动窗口算法的要求，即序号空间是窗口空间的两倍以上。现分别考虑两字段。</p><p><strong>32 位序号空间的相关问题</strong>是，某个连接使用的序号可能会回绕，即具有序号 x 的一个字节在某个时刻被发送出，一段时间后，第二个具有序号 x 的字节也有可能被发出，在假设一个分组在因特网上的生存期不超过 MSL 的情况下，任务就是确保序号在该期限内不会回绕。这取决于数据在因特网上传输的速度：</p><p><img src="https://gitee.com/kaijietti/image-host/raw/master/20210329160755.png" alt="32 比特序号空间的回绕时间"></p><p>对于当前因特网的主干网的高速链路来说，32 位的序号空间是不足够的，但通过时间戳的拓展选项可以对序号进行“拓展”，从而能够进行区分，也就解决了回绕的问题。</p><p><strong>16 位 AdvertisedWindow 字段的相关问题</strong>是，它必须足够大以使得发送方能够保持管道满载。假设接收方有足够的缓冲空间可以处理 AdvertisedWindow 所允许的最大数据量的情况。此时，窗口应尽量开放的足够大，使得数量为 <code>延迟 * 带宽</code> 的全部数据能被传输。假设有 100ms 的 RTT，下图给出了几种网络技术的延迟带宽积。</p><p><img src="https://gitee.com/kaijietti/image-host/raw/master/20210329160944.png" alt="100ms RTT 所需的窗口大小"></p><p>可以看出，AdvertisedWindow 的大小甚至不足以处理横穿美国大陆的 T3 连接，因为 16 比特的字段只允许 64KB 的通知窗口。但 TCP 提供选项支持对滑动窗口的拓展使其能够填充可能由高速网络形成的更大的 <code>延迟 * 带宽</code> 通道。</p><h3 id="3-2-触发传输"><a href="#3-2-触发传输" class="headerlink" title="3.2 触发传输"></a>3.2 触发传输</h3><p>拉书中一个对何时进行分组发送的探讨</p><h2 id="4-拥塞控制"><a href="#4-拥塞控制" class="headerlink" title="4 拥塞控制"></a>4 拥塞控制</h2><h3 id="4-1-拥塞控制的一般原理"><a href="#4-1-拥塞控制的一般原理" class="headerlink" title="4.1 拥塞控制的一般原理"></a>4.1 拥塞控制的一般原理</h3><blockquote><p>整理自谢书，主要理解拥塞控制的概念及其与流量控制的联系与区别。</p></blockquote><p>在计算机网络中的链路容量（即带宽）、交换节点中的缓存和处理机等，都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做<strong>拥塞（congestion）</strong>。若网络中的许多资源同时呈现供应不足，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。</p><p>网络拥塞往往是由许多因素引起的，且通常无法靠增加某种资源量来解决。例如，当某个结点缓存的通量太少时，到达该结点的分组因无存储空间暂存而不得不被丢弃。设想增大该结点的缓存容量使得凡到达该结点的分组均可在结点的缓存队列中排队，但由于输出链路的容量和处理机的速度并未提高，该队列中的绝大多数分组的排队等待时间大大增加，最终只能“被超时”而后重新由上层软件将它们重传。又如，处理机处理的速率太慢引起网络的拥塞，简单将其效率提高可能会使情况缓解一些，但<strong>往往又会将瓶颈转移到其他地方</strong>。所以问题的本质往往是<strong>整个系统的各个部分不匹配</strong>。</p><p>拥塞控制与流量控制关系密切但存在差别：</p><ul><li><strong>拥塞控制是防止注入过多的数据到网络中，使网络中的路由器或链路不致过载</strong>。拥塞控制的前提是<strong>网络能够承受现有的网络负荷</strong>。拥塞控制是一个<strong>全局性的过程</strong>，涉及到所有的主机、路由器以及降低网络传输性能有关的所有因素。</li><li><strong>流量控制往往是指点到点通信量的控制</strong>，是个<strong>端到端</strong>的问题（接收端控制发送端）。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li></ul><blockquote><p>两者存在混淆的原因是在实现上两者有相似的机制即向发送端发送控制报文以通知其网络/对端出现麻烦，需要放慢发送速率。</p></blockquote><p>在实际网络中，随着网络提供的负载的增大，网络吞吐量的增长速率逐渐减小（提供的负载表示单位时间内输入给网络的分组数，吞吐量表示单位时间内从网络输出的分组数）。也就是说，在网络吞吐量还未达到饱和时，就已经有部分分组被丢弃了，当网络吞吐量明显小于理想值（即输入与输出相抵）时，网络就进入轻度拥塞状态。当提供的负载增大到某一数值时，网络吞吐量下降到零，出现死锁。</p><blockquote><p>谢书提到，分组的丢失是网络发生拥塞的征兆而不是原因，所以拥塞引起的重传实质上并不会缓解拥塞（在不加以拥塞控制的情况下）。甚至在许多情况下，正是拥塞控制机制本身成为引起网络性能恶化或发生死锁的原因。书本还更进一步从控制理论的角度看待拥塞控制问题，这里就不展开了。</p></blockquote><h3 id="4-2-TCP-拥塞控制"><a href="#4-2-TCP-拥塞控制" class="headerlink" title="4.2 TCP 拥塞控制"></a>4.2 TCP 拥塞控制</h3><p>林书中对 TCP 拥塞控制思想进行了描述：</p><p>TCP 发送者是通过检测数据分段丢失事件来推断网络是否拥塞。一个丢失事件后，发送者会礼貌地减慢其传输速率并保持在将会触发丢失事件的速率以下。这样做的目的在于取得资源有效利用率的同时避免网络拥塞。通常，TCP 拥塞控制的思想就是为每个 TCP 头部确定从发送者到接收者路由路径上的可用带宽，所以它知道发送多少分段是安全的。</p><p>RFC 793 中定义了 TCP 的基本结构：即基于窗口的流量控制和粗粒度的重传定时器（此时并没有定义拥塞控制）。随后互联网经历了<em>拥塞崩溃</em>，此时发布的 TCP Tahoe，增加了由 Van Jacobson 提出的<em>拥塞避免</em>和<em>快速重传</em>方案。后来，RFC 2001 对（在 Tahoe 基础上）添加了<em>快速恢复</em>的 TCP Reno 进行标准化。在对 Reno 版本出现的问题的解决过程中又迭代了很多 TCP 版本，如 NewReno，SACK/FACK 和 Vegas 等等。如果想要了解整个迭代过程，建议把 RFC 的 TCP 系列都拿出来读读（RFC 7414 和 RFC 7805 列出了该系列）。</p><p>另外要说明的是，拥塞控制的基本算法包括慢开始（slow-start）、拥塞避免（congestion avoidance）、快重传（fast retransmit）和快恢复（fast recovery），可在 RFC 5681 中查阅，但涉及比较多的实现细节比如如何设置初始拥塞窗口值等等，但个人能力有限，所以下文中的具体实现均来自林书，读者还是先读读谢书中的相关小节来体验一遍以上四种算法比较好。</p><blockquote><p>谢书只讲了 Reno 版本，但图示和解释容易理解，林书讲得更细致，涉及多个 TCP 版本</p></blockquote><h3 id="4-3-TCP-Tahoe-拥塞控制"><a href="#4-3-TCP-Tahoe-拥塞控制" class="headerlink" title="4.3 TCP Tahoe 拥塞控制"></a>4.3 TCP Tahoe 拥塞控制</h3><blockquote><p>论文 <em>A Comparative Analysis of TCP Tahoe, Reno, New-Reno, SACK and Vegas</em> 中提到的 Tahoe 版本与林书提到的不同，前者没有快速重传，其它与林书的版本一致。注意，快速重传是要求接收方<strong>不能</strong>在发送数据时才捎带（piggyback）确认，而是要<strong>立即发送确认</strong>，即便是收到了失序的报文段也要立即发出对已收到的报文段的重复确认。如果接收方只使用累积确认，则易导致发送方<em>回退N（Go back N）</em>。注意，累积确认只对最近按序到达的最后一个分组进行确认，对中间错序到达的分组不会进行确认。累积确认的优点是 ACK 丢失也不必重传，但缺点是不能向发送方反映出接收方已经正确收到的所有分组的信息。</p></blockquote><p>Tahoe 使用拥塞窗口（cwnd）控制在一个往返时间（RTT）内传输的数据量，使用最大窗口（mwnd）约束 cwnd 的最大值。Tahoe 以 <code>snd.nxt - snd.una</code> 的形式估计未经确认的数据量 awnd，<strong>当 awnd 小于 cwnd 时，发送方继续发送新的分组；否则，发送方停止发送</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> From RFC 793</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SND.UNA - send unacknowledged</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SND.NXT - send next</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SND.WND - send window</span></span><br><span class="line">Send Sequence Space</span><br><span class="line">    1         2          3          4</span><br><span class="line">----------|----------|----------|----------</span><br><span class="line">        SND.UNA    SND.NXT    SND.UNA</span><br><span class="line">                            +SND.WND</span><br><span class="line"></span><br><span class="line">1 - old sequence numbers which have been acknowledged</span><br><span class="line">2 - sequence numbers of unacknowledged data</span><br><span class="line">3 - sequence numbers allowed for new data transmission</span><br><span class="line">4 - future sequence numbers which are not yet allowed</span><br></pre></td></tr></table></figure><p>Tahoe 的控制方案可分为四种状态，转换图如下：</p><p><img src="https://gitee.com/kaijietti/image-host/raw/master/20210323155224.png" alt="TCP Tahoe 拥塞控制算法"></p><p><strong>慢启动</strong>：慢启动旨在短短的几个 RTT 时间内迅速探测到可用的带宽。当一个连接启动或重传发生时，通过将 cwnd 的初始值设置成一个分组开始慢启动状态，即 MSS。发送方通过每次只要收到一个 ACK 时就添加一个 MSS 到 cwnd 中而呈<em>指数地</em>增加 cwnd。经过每个 RTT（一个传输轮次经历的时间 RTT 并非恒定数值） 后，如果所有的 ACK 正确及时地收到，就加倍 cwnd，如下图所示，慢启动并不慢。</p><p><img src="https://gitee.com/kaijietti/image-host/raw/master/20210323191139.png" alt="慢启动过程传输分组演示图"></p><p>当 cwnd 达到慢启动的阈值 ssthresh 时，TCP 进入拥塞避免状态。注意，当发起一次连接时，将 ssthresh 设置为其数据类型下的最大值，表示不限制慢启动带宽探测。在慢启动状态下，如果收到三个重复的 ACK 或者出现 RTO（重传超时）会分别进入快速重传状态或重传超时状态。</p><p><strong>拥塞避免</strong>：拥塞避免的目的在于<em>缓慢地</em>探测可用带宽，但<em>迅速地</em>响应拥塞事件。它遵循<strong>加法增加乘法减少（AIMD）</strong> 的原则。由于慢启动状态中的窗口大小呈指数增加，所以以此不断增加的速度发送分组就会很快导致网络拥塞。为了避免这种情况，当 cwnd 超过 ssthresh 时就会启动拥塞避免状态。在这种状态下，一旦收到一个 ACK，cwnd 就会增加 1/cwnd 个分组，从而使得窗口的大小呈线性地增长。因此，cwnd 通常没经过一个 RTT 后就会大致增加 1，如下图所示：</p><p><img src="https://gitee.com/kaijietti/image-host/raw/master/20210323195001.png" alt="拥塞避免期间传输分组演示图"></p><p>拥塞避免状态和在慢启动状态下一样，如果收到三个重复的 ACK 或者出现 RTO（重传超时）会分别进入快速重传状态或重传超时状态。</p><blockquote><p>谢书：前面的描述中 cwnd 的单位是报文段个数，实际上应当是字节为单位，即 cwnd 增加 1 代表拥塞窗口增加一个 MSS 的大小，单位为字节。对于 <code>cwnd += 1/cwnd</code>，实现上以字节为单位时可以写为：<code>cwnd += (MSS*MSS)/cwnd</code>。此处书本的举例并不正确，因为每次增加的字节数并不是常量，且最终每个 RTT 后 cwnd 并不是恰好增加 1。</p></blockquote><p><strong>快速重传</strong>：快速重传的目的是立即传送丢失的分组而无需等待重传定时器超时。重复的 ACK 是由于丢失的分组，或者由于重复的分组，或者由于在接收方收到无序的分组所造成的。在丢失分组的情况下，发送方应该重传。由于发送方不知道什么原因导致出现重复的 ACK，所以快速重传采用启发式算法：如果接收到三个或更多的重复 ACK，那么 TCP 发送方就假定已经发生了分组丢失。随后发送方重传假定丢失的分组，而无需等待一个粗粒度的重传定时器超时。发送方传输了丢失的分组后，根据 AIMD 将 ssthresh 减少为 cwnd/2，将 cwnd 重置为 1 进入慢启动状态。</p><p><strong>重传超时</strong>：重传超时提供最后的也是最慢的重传丢失分组的方法。发送方维护一个重传定时器用来检测 ACK 的超时。如果发生超时，如快速重传状态中的处理，发送方将 ssthresh 减少为 cwnd/2，将 cwnd 重置为 1 进入慢启动状态。</p><h3 id="4-4-TCP-Reno-拥塞控制"><a href="#4-4-TCP-Reno-拥塞控制" class="headerlink" title="4.4 TCP Reno 拥塞控制"></a>4.4 TCP Reno 拥塞控制</h3><p>TCP Reno 通过将<em>快速恢复</em>状态引入分组丢失后的后续恢复阶段，扩展了 Tahoe 拥塞控制方案。<strong>快速恢复将注意力集中在 在网络管道中保留足够未经确认的分组，以便保留 TCP 的自同步行为（self-clocking）</strong>。</p><blockquote><p>关于网络管道和 TCP 自同步行为将在后面的性能问题小节介绍。可以暂时把自同步行为简化成由接收方发送的 ACK 驱动发送方发送下一个分组。</p></blockquote><p>当执行快速重传时，TCP Reno 将 ssthresh 设置为 cwnd/2，然后将 cwnd 设置为 ssthresh+3，此处的 <code>+3</code> 是由于目前三个重复的 ACK。</p><p>这里的 cwnd 值的设置值得品味：每一个收到的重复 ACK 实际上意味着某一个分组已经退出网络管道（在接收方缓存中），因此对于触发快速重传的三个重复 ACK，更正确的思路是将 awnd 减 3，其中 awnd 是在网络管道中未经确认的分组的数量。然而，在 Reno 中，awnd 的计算是<code>snd.nxt - snd.una</code>，在此状态下是固定不变的，因此 Reno 增加 cwnd 而不是减少 awnd 来达到同样的目的。当收到重传假定丢失分组的确认时，cwnd 重置为老的 cwnd 值的一半。TCP Reno 的状态转换图如下（红字部分为对原书配图的修改）：</p><p><img src="https://gitee.com/kaijietti/image-host/raw/master/20210324184523.png" alt="TCP Reno 拥塞控制算法"></p><p>快速恢复状态的引入是因为我们不仅能从多个重复 ACK 推断出某分组的大概率丢失，还能进一步假定此前窗口发送的某些分组已经到达接收方（否则不太可能会有多个重复 ACK）。因此，图中的快速恢复状态中，每接收到一个重复 ACK，我们递增 cwnd，从而可以发送新的分组（想一想前面提到的如果 cwnd 小于 awnd 我们就无法发送分组），所以，即便是分组丢失，Reno 也可以让网络管道继续交换分组，而反观 Tahoe，它在快速重传状态时设置 cwnd 为 1，使得在重传的分组的 ACK 未到达发送方前，发送方都在干等（因为 cnwd=1 &lt; awnd 无法发送分组）。</p><blockquote><p>上面的解释也说明了为什么 Reno 保留了 TCP 的自同步行为，因为 Tahoe 的拥塞窗口的设置不妥，使得后续到达的<strong>重复 ACK</strong> 并没有办法让新的分组发出。注意，这里说的是重复 ACK，如果是新的 ACK，它能够驱使 awnd 缩小到比 cwnd 还小从而能够继续发送新分组。</p></blockquote><p>状态图中快速恢复状态的行为可以结合下图进行理解：</p><p><img src="https://gitee.com/kaijietti/image-host/raw/master/20210324170522.png" alt="TCP Reno 对 cwnd 值的设置解释图"></p><p>为了更进一步阐述区别，林书提供了一个示例对比 Tahoe 与 Reno 的行为区别，我认为特别有必要学习：</p><p><img src="https://gitee.com/kaijietti/image-host/raw/master/20210324172839.png" alt="TCP Tahoe 拥塞控制的例子"></p><p><img src="https://gitee.com/kaijietti/image-host/raw/master/20210324173815.png" alt="TCP Reno 拥塞控制的例子"></p><p>在两幅例子的步骤 4 中，Tahoe 不能发送任何新的分组了，但 Reno 却可以，因此很明显，在分组丢失后 TCP Reno 利用快速恢复得到更高效的传输。但是，Reno 存在多分组丢失（Multiple Packet Loss，MPL）问题，降低了其性能，书本提到的四种解决方案分别是 New Reno、SACK、FACK 和 Vegas，由于我还未能完全理解，请读者自行查阅。</p><h2 id="5-定时器管理"><a href="#5-定时器管理" class="headerlink" title="5 定时器管理"></a>5 定时器管理</h2><p>每个 TCP 连接都会维护一组定时器以驱动其状态机。本节介绍 TCP 的定时器管理，其中详细研究了两种强制的定时器，重传定时器和坚持定时器，以及一个可选的定时器，保活定时器。</p><h3 id="5-1-连接定时器"><a href="#5-1-连接定时器" class="headerlink" title="5.1 连接定时器"></a>5.1 连接定时器</h3><p>为了建立一条新的 TCP 连接，发送方发送一个 SYN 分组，并同时启动连接定时器。若 SYN 分组丢失，在定时器超时后会发送方会重发 SYN 分组直到达到最大重发次数或者收到接收方的确认。</p><h3 id="5-2-重传定时器"><a href="#5-2-重传定时器" class="headerlink" title="5.2 重传定时器"></a>5.2 重传定时器</h3><p>重传定时器在TCP发送数据时设定，在计时器超时后没有收到返回的确认ACK，发送端就会重新需要重传的分组。超时重传时间的设置十分重要，如果设置的过短，就会引起很多分组的不必要的重传，使网络负荷增大。但若把超时重传时间设置得过长，则又使网络的空闲时间增大，降低了吞吐量和传输效率。TCP 采用自适应重传机制来设置超时重传时间。对于重传超时的估计，请查阅 RFC 6928。</p><h3 id="5-3-延迟-ACK-定时器"><a href="#5-3-延迟-ACK-定时器" class="headerlink" title="5.3 延迟 ACK 定时器"></a>5.3 延迟 ACK 定时器</h3><p>关于延迟 ACK，RFC 1122 有相关讨论：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">4.2.3.2  When to Send an ACK Segment</span><br><span class="line">A host that is receiving a stream of TCP data segments can</span><br><span class="line">increase efficiency in both the Internet and the hosts by</span><br><span class="line">sending fewer than one ACK (acknowledgment) segment per data</span><br><span class="line">segment received; this is known as a &quot;delayed ACK&quot; [TCP:5].</span><br><span class="line"></span><br><span class="line">A TCP SHOULD implement a delayed ACK, but an ACK should not</span><br><span class="line">be excessively delayed; in particular, the delay MUST be</span><br><span class="line">less than 0.5 seconds, and in a stream of full-sized</span><br><span class="line">segments there SHOULD be an ACK for at least every second</span><br><span class="line">segment.</span><br><span class="line"></span><br><span class="line">DISCUSSION:</span><br><span class="line">A delayed ACK gives the application an opportunity to</span><br><span class="line">update the window and perhaps to send an immediate</span><br><span class="line">response.  In particular, in the case of character-mode</span><br><span class="line">remote login, a delayed ACK can reduce the number of</span><br><span class="line">segments sent by the server by a factor of 3 (ACK,</span><br><span class="line">window update, and echo character all combined in one</span><br><span class="line">segment).</span><br><span class="line"></span><br><span class="line">In addition, on some large multi-user hosts, a delayed</span><br><span class="line">ACK can substantially reduce protocol processing</span><br><span class="line">overhead by reducing the total number of packets to be</span><br><span class="line">processed [TCP:5].  However, excessive delays on ACK&#x27;s</span><br><span class="line">can disturb the round-trip timing and packet &quot;clocking&quot;</span><br><span class="line">algorithms [TCP:7].</span><br><span class="line"></span><br><span class="line">[TCP:5] &quot;Window and Acknowledgment Strategy in TCP,&quot; D. Clark, RFC-813,</span><br><span class="line"><span class="code">     July 1982.</span></span><br><span class="line"><span class="code">[TCP:7] &quot;Congestion Avoidance and Control,&quot; V. Jacobson, ACM SIGCOMM-88,</span></span><br><span class="line"><span class="code">     August 1988.</span></span><br></pre></td></tr></table></figure><p>延迟 ACK 的目的是提高网络传输的效率，防止过多的小分组占用带宽。接收方必须等待延迟 ACK 定时器超时才发送 ACK，如果在此期间有数据需要发送，那么它就用捎带方法发送 ACK。</p><blockquote><p>前文列出 RFC 1122 的相关讨论是因为我目前还没有弄懂延迟 ACK 对前面的拥塞控制算法的快速重传要求立即发送 ACK 是否有很大的影响。还有待进一步学习。</p></blockquote><h3 id="5-4-坚持定时器（persistence-timer）"><a href="#5-4-坚持定时器（persistence-timer）" class="headerlink" title="5.4 坚持定时器（persistence timer）"></a>5.4 坚持定时器（persistence timer）</h3><blockquote><p>RFC 6429: <em>It is extremely important to remember that ACK (acknowledgment) segments that contain no data are not reliably transmitted by TCP.</em> 翻译过来是，TCP 不对不含数据的 ACK 分组保障可靠传输，这其实是说如果对纯 ACK 分组也进行如正常数据分组需要被确认的操作，那么将会导致系列问题如确认的确认、确认的确认的确认……。</p></blockquote><p>TCP 坚持定时器只是为了避免以下死锁：接收方发送一个接收窗口大小为 0 的确认告诉发送方等待，而后接收方更新并通告它的窗口大小但该分组丢失。现在双方都在等待对方做出行动，这就是发生了死锁。</p><blockquote><p>这里可能有疑惑的地方就是，为什么接收方自己不会因为重传定时器超时而重发更新窗口发小的分组呢？后来在查阅资料时发现对于重传定时器起作用的分组是带数据的分组（带数据分组应该拓宽为消耗序列号的分组，如 SYN+ACK 分组就算不带数据但由于 SYN 消耗序列号它也会启动重传定时器），这么做的目的是在定时器超时前期待接收到对该分组的确认。若对不消耗序列号的分组也进行确认，就会陷入前面引用中提到的问题（确认的确认）。而对于通知窗口更新的分组而言，它只是变动了窗口值的分组，并不存在特殊的标志位标记（于是不能像 SYN 之类的一样指明这类分组需要被确认）区分于纯 ACK 分组（那窗口更新的分组就是一个纯 ACK 分组），所以它也是不会被确认的（如果我的理解有误请指正，谢谢），那么也不会启动定时器让它能够超时重传。</p></blockquote><p>所以，在发送方收到窗口大小为 0 的确认时，可以启动坚持定时器来周期性地向接收方发送一个零窗口探测分组（携带 1 个字节的数据，目的是为了触发其响应），对于该分组的确认就带回了窗口大小，如果仍旧是 0 ，那么坚持定时器就再次重置；如果不为 0，死锁的局面被打破，进而可以发送数据。</p><blockquote><p>谢书注：TCP 规定，即使设置为零窗口，也必须接收以下几种分组：零窗口探测分组，确认分组和携带紧急数据的分组。<br>拉书注：由发送方解决该问题的原因是：TCP 被设计成接收方尽可能地简单，即它只响应从发送方来的分组，而它自己从不发起任何行动。这是公认的（尽管不是通用的）协议设计规则的一个例子，称为聪明的发送方/笨拙的接收方（smart sender / dumb receiver）规则。</p></blockquote><h3 id="5-5-保活定时器"><a href="#5-5-保活定时器" class="headerlink" title="5.5 保活定时器"></a>5.5 保活定时器</h3><p>通过 TCP/IP 检测已经崩溃的系统很困难。如果应用程序不发送任何信息，TCP 就需要在连接上传输任何信息，TCP/IP 使用的许多介质（以太网）并不提供可靠的方法来判断一个特定的主机是否打开。如果一台服务器没有从客户机收到什么。那么很可能：</p><ul><li>它什么都没法送</li><li>在服务器和客户机之间的网络可能发生了故障</li><li>服务器和客户机的网络接口可能断开了</li><li>客户机已经崩溃</li></ul><p>其中，网络故障经常是暂时的，那么不应该以放弃 TCP 连接而告终。</p><p>保活是 API 套接字的一个特征，它周期性地在空闲的链路上发送空分组：</p><ul><li>如果远程系统仍然正常，本地系统将会得到一个确认</li><li>如果远程系统已经重启，本地系统将会得到一个 RST 分组释放该连接</li><li>如果远程系统已经崩溃，本地系统将会得到超时</li></ul><p>保活定时器设置的时长较长，目的不是立即检测对端系统，而是让不需要的资源不永远地占用。<strong>所以如果需要更快地检测对端系统，就应该在应用层协议中实现它</strong>。</p><h3 id="5-6-FIN-WAIT-2-定时器"><a href="#5-6-FIN-WAIT-2-定时器" class="headerlink" title="5.6 FIN_WAIT_2 定时器"></a>5.6 FIN_WAIT_2 定时器</h3><p>执行主动关闭的一方在发送完 FIN 分组并接收到对该分组的确认时，TCP 进入 FIN_WAIT_2 状态。倘若此时没有该定时器并且连接另一方宕机或两方之间的网络中断，该连接将会一直无法被关闭，导致系统资源的浪费。FIN_WAIT_2 定时器能够避免一条链接一直停留在 FIN_WAIT_2 状态，如果在该定时器超时的时候还是没收到被动关闭一方的 FIN 分组，直接释放该连接。</p><h3 id="5-7-TIME-WAIT-定时器"><a href="#5-7-TIME-WAIT-定时器" class="headerlink" title="5.7 TIME_WAIT 定时器"></a>5.7 TIME_WAIT 定时器</h3><p>该定时器用于 TIME_WAIT 状态以便进入 CLOSED 状态，关于该定时器的作用在前面<strong>连接释放</strong>小节已经说明。</p><h2 id="6-TCP-性能问题以及增强"><a href="#6-TCP-性能问题以及增强" class="headerlink" title="6 TCP 性能问题以及增强"></a>6 TCP 性能问题以及增强</h2><p>基于 TCP 应用的传送方式可以分为：<em>交互式连接</em>和<em>批量数据传输</em>。这两种数据传送方式有各自的性能问题，书本分别提到了糊涂窗口综合症（Silly Window Syndrome，SWS）和 TCP Reno 的多分组丢失问题（Multiple Packet Loss，MPL）。</p><h3 id="6-1-糊涂窗口综合症"><a href="#6-1-糊涂窗口综合症" class="headerlink" title="6.1 糊涂窗口综合症"></a>6.1 糊涂窗口综合症</h3><p>对于交互式事务，使用滑动窗口进行流量控制时 TCP 会经历一种状态：糊涂窗口综合症。当处于此状态时，同样多的数据量，在连接中会发出更多的小分组而不是完整分组，而由于每个分组都由固定大小的头部开销，更多的小分组则意味着带宽的浪费。</p><p>SWS 状态可由任何一端引起：</p><ul><li>发送端可以发送一个小的分组，而不等待发送应用程序发送的更多数据以便以完整尺寸的分组来发送。例如 telnet 的远程登陆：因为在远程登陆中每次按键都会产生一个分组和一个 ACK，通过 WAN（广域网）很长的往返时间，远程登陆会浪费全球共享的 WAN 带宽。</li><li>接收端可以通告一个小于完整分组大小的窗口，而不等待片刻以便能从缓冲区中移动更多数据到接受应用程序从而腾出缓冲空间。</li></ul><p><strong>解决方案</strong></p><p>为了阻止发送端引起 SWS，可用 Nagle 算法，该算法能够在带宽饱和时减少发送分组的数量：除非此时没有已发出的数据（或者说，未经确认的数据），否则不发送小分段。相反，Nagle 将小的分段收集到一起当 ACK 到达时再一起发送。Nagle 算法的优秀归功于它的<em>自同步（self-clocking）行为</em> : 如果 ACK 回来得很快，带宽就可能很大从而分组发送得也快；如果 ACK 回来得很慢，这意味着窄带路径，此时 Nagle 算法就会通过发送完整大小的分段来减少小分段的数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> there <span class="keyword">is</span> new data to send</span><br><span class="line">    <span class="keyword">if</span> window size &gt;= MSS <span class="keyword">and</span> available data &gt;= MSS</span><br><span class="line">        send complete MSS segment</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> there <span class="keyword">is</span> outstanding data <span class="keyword">and</span> queued data live time &lt;threshold  </span><br><span class="line">            enqueue data <span class="keyword">in</span> the buffer until an ACK <span class="keyword">is</span> received</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            send  data  immediately</span><br><span class="line">        endif  </span><br><span class="line">    endif</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>为了防止接收端进入 SWS 状态，可用 David D. Clark 提出的解决方案：通告声明会被延迟直到接收方缓冲区有一半是空的或者能够装下整个分段，从而为发送方保证一个大窗口通告，当然延迟也是受限制的。</p><h3 id="6-2-多分组丢失问题"><a href="#6-2-多分组丢失问题" class="headerlink" title="6.2 多分组丢失问题"></a>6.2 多分组丢失问题</h3><p>在 Reno 中，当一个窗口发生多分组丢失时，接收方总是利用重复 ACK 作为响应，因为发送方假设每个 RTT 最多只有一个新的丢失。此时，发送方必须花费多个 RTT 来解决所有这些丢失。同时，重传超时更加频繁，因为尽管有许多未被确认的分组等待重传，但只有少数的分组（由于快速重传触发的 cwnd 的减少而限制）才能发送。下面是 MPL 问题的一种表现。</p><p><img src="https://gitee.com/kaijietti/image-host/raw/master/20210405194723.png" alt="Reno 的多分组丢失问题"></p><p>注意，挡在一个数据窗口中丢失多个分组时，Reno 并不总是超时。当 cwnd 非常大的情况下发生多个丢失事件时，任何部分 ACK 不仅使 Reno 退出快速恢复，而且还会由于另外一批三个重复的 ACK 而触发另一个快速重传。这的确符合要求，尽管它会减慢丢失恢复。但是，如果太多的分组在一个 RTT 内丢失，那么将会引起 cwnd 在下一个 RTT 内减半很多次以至于太少的未经确认的报文在管道中而不能触发下一次快速重传，Reno 将超时，这将进一步延长丢失恢复。</p><p><strong>解决方案 1：TCP NewReno</strong></p><p>NewReno 修改了 Reno 快速恢复阶段以缓解 MPL 问题。仅当发送方在检测到第一个丢失分组之前接收到最后发送分组的 ACK 时，它才会脱离原始的快速恢复。在该终止点之前的非重复 ACK 都被当做部分 ACK。</p><p>Reno 将部分 ACK 当作是丢失分组的以此成功重传，因此发送方回到拥塞避免状态以便发送新的分组。相反，NewReno 认为这是一种进一步发生分组丢失的信号，因此发送方立即重传丢失的分组。当部分 ACK 到达后，发送方通过</p><p><img src="https://gitee.com/kaijietti/image-host/raw/master/20210405212721.png" alt="TCP NewReno 处理 MPL 问题 (1)"></p><p><img src="https://gitee.com/kaijietti/image-host/raw/master/20210405220039.png" alt="TCP NewReno 处理 MPL 问题 (2)"></p><p><strong>解决方案 2：TCP SACK</strong></p><p><strong>解决方案 3：TCP FACK</strong></p><p><strong>解决方案 4：TCP Vegas</strong></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p>在学习过程中，发现了许多优秀的学习资源：</p><ul><li><strong>An Introduction to Computer Networks</strong>：<em><a target="_blank" rel="noopener external nofollow noreferrer" href="http://intronetworks.cs.luc.edu/current/html/index.html#">http://intronetworks.cs.luc.edu/current/html/index.html#</a></em></li><li></li></ul></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2021/03/15/操作系统精髓与设计原理：线程/" rel="bookmark">操作系统精髓与设计原理：线程</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2021/03/08/操作系统精髓与设计原理：进程的描述与控制/" rel="bookmark">操作系统精髓与设计原理：进程的描述与控制</a></div></li></ul><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> kaijietti</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://kaijietti.github.io/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9ATCP/" title="计算机网络：TCP（未完成草稿）">https://kaijietti.github.io/2021/04/11/计算机网络：TCP/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="https://twitter.com/gohell49713918" rel="external nofollow noreferrer"><span class="icon"><i class="fab fa-twitter"></i></span> <span class="label">Twitter</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="/images/wechat_channel.png"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 读书笔记</a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"><i class="fa fa-tag"></i> 计算机网络</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%EF%BC%9A%E7%BA%BF%E7%A8%8B/" rel="prev" title="操作系统精髓与设计原理：线程"><i class="fa fa-chevron-left"></i> 操作系统精髓与设计原理：线程</a></div><div class="post-nav-item"></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E7%9A%84%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93%EF%BC%9ATCP"><span class="nav-number">1.</span> <span class="nav-text">可靠的面向连接的传输：TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text">1 连接管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-0-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.0 有限状态机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.1 连接建立</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.2 连接释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%88%86%E7%BB%84%E6%B6%88%E8%80%97%E5%BA%8F%E5%88%97%E5%8F%B7%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.3 分组消耗序列号的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E4%B8%8E%E5%A5%97%E6%8E%A5%E5%AD%97-API-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.1.5.</span> <span class="nav-text">1.4 连接状态与套接字 API 的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">2 数据传输的可靠性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%88%86%E6%AE%B5%E7%9A%84%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%EF%BC%9A%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 分段的差错控制：校验和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%B5%81%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8F%B7%E5%92%8C%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 流的可靠性：序列号和确认应答</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 异常情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">1.3.</span> <span class="nav-text">3 流量控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 滑动窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-TCP-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 TCP 滑动窗口算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E8%A7%A6%E5%8F%91%E4%BC%A0%E8%BE%93"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.2 触发传输</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">1.4.</span> <span class="nav-text">4 拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E4%B8%80%E8%88%AC%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 拥塞控制的一般原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2 TCP 拥塞控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-TCP-Tahoe-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.3 TCP Tahoe 拥塞控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-TCP-Reno-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">1.4.4.</span> <span class="nav-text">4.4 TCP Reno 拥塞控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.5.</span> <span class="nav-text">5 定时器管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E8%BF%9E%E6%8E%A5%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">1.5.1.</span> <span class="nav-text">5.1 连接定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E9%87%8D%E4%BC%A0%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">1.5.2.</span> <span class="nav-text">5.2 重传定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E5%BB%B6%E8%BF%9F-ACK-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">1.5.3.</span> <span class="nav-text">5.3 延迟 ACK 定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E5%9D%9A%E6%8C%81%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88persistence-timer%EF%BC%89"><span class="nav-number">1.5.4.</span> <span class="nav-text">5.4 坚持定时器（persistence timer）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E4%BF%9D%E6%B4%BB%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">1.5.5.</span> <span class="nav-text">5.5 保活定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-FIN-WAIT-2-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">1.5.6.</span> <span class="nav-text">5.6 FIN_WAIT_2 定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-TIME-WAIT-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">1.5.7.</span> <span class="nav-text">5.7 TIME_WAIT 定时器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-TCP-%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E5%A2%9E%E5%BC%BA"><span class="nav-number">1.6.</span> <span class="nav-text">6 TCP 性能问题以及增强</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E7%97%87"><span class="nav-number">1.6.1.</span> <span class="nav-text">6.1 糊涂窗口综合症</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E5%A4%9A%E5%88%86%E7%BB%84%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="nav-number">1.6.2.</span> <span class="nav-text">6.2 多分组丢失问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB"><span class="nav-number">1.7.</span> <span class="nav-text">推荐阅读</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="kaijietti" src="/images/avatar.gif"><p class="site-author-name" itemprop="name">kaijietti</p><div class="site-description" itemprop="description">专注技术分享</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">4</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/kaijietti" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kaijietti" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i></a></span><span class="links-of-author-item"><a href="mailto:guokaijie45@gmail.com" title="E-Mail → mailto:guokaijie45@gmail.com" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i></a></span><span class="links-of-author-item"><a href="https://twitter.com/gohell49713918" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;gohell49713918" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-twitter fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener external nofollow noreferrer" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">kaijietti</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">NexT.Pisces</a> 强力驱动</div><div class="busuanzi-count"><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="127,127,127" opacity="0.5" zindex="-1" count="88" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/pjax/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script src="/js/local-search.js"></script><div id="pjax"><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'oHLTTSCp8hpgowb2FC8KYc1l-gzGzoHsz',
      appKey     : 'YGQ94hekqYsjhfMzUXROg98L',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script><div class="moon-menu"><div class="moon-menu-items"><div class="moon-menu-item" onclick="back2bottom()"><i class="fas fa-chevron-down"></i></div><div class="moon-menu-item" onclick="back2top()"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script></div></body></html>